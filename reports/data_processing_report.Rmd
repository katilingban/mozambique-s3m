---
title: "Sofala Simple Spatial Survey Method (S3M)"
subtitle: "Survey Data Cleaning and Processing Report"
author: 
    - name: Mark Myatt
    - name: Ernest Guevarra
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
    toc_depth: 4
    self_contained: true
    code_download: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  echo = FALSE
)

suppressPackageStartupMessages(source("packages.R"))
for (f in list.files(here::here("R"), full.names = TRUE)) source (f)

targets::tar_load(
  c()
)
```

<style type="text/css">
  body{
  font-size: 12pt;
}
</style>

<br/>

## Overview of data cleaning and processing procedures implemented

This document provides information on the data cleaning and processing procedures applied to the dataset from the Sofala Simple Spatial Survey Method (S3M) survey. These procedures were implemented on the dataset using the [R language for statistical computing](https://www.r-project.org/)[^1]. These data cleaning and processing procedures were conceived and designed in such a way that they can be used for the data cleaning and processing of the Nampula and Zambezia endline survey dataset as well, given its similar data structure and indicator sets with only minor differences in variable naming and with some variables for infant and young child feeding. As such, attention and effort were put into designing generalisable R functions that can be used across the datasets and for each of the specific indicator sets common to both surveys.

These general and indicator set-specific functions for data cleaning and processing are mainly functions that perform the following procedures:

* Recoding of the responses to appropriate values that will allow for further recoding of responses into appropriate indicator definitions (see next point) and/or allow for subsequent analysis;

* Recoding of the responses into appropriate indicator definitions (specifically for indiators that require responses from multiple questions/variables such as IYCF, WASH, and the like); and,

* Restructuring of the recoded dataset/s to allow for subseqent analysis.

In this document, we describe these general functions used to process the data across all indicators sets, and we describe the the indicator set-specific functions used to process each indiator set.

<br/>

## General functions used across most indicator sets

Following are the general functions used across majority of the indicator sets.

### Get core variables required for analysis

```r
################################################################################
#
#'
#' Get core variables required for analysis
#'
#' @param raw_data_clean A roughly cleaned/processed raw dataset 
#'
#
################################################################################

get_core_variables <- function(raw_data_clean) {
  raw_data_clean |>
    subset(
      select = c(
        id, spid, district, ea_code, geolocation
      )
    )
}
```

This is a convenience function to retrieve identifier variables required for analysis. These variables are:

```{r survey_vars}
vars <- c("id", "spid", "district", "ea_code", "geolocation")
desc <- c("Unique identifier", "Sampling point identifier", "District name", "Enumeration area code", "Geolocation")

data.frame(vars, desc) |>
  knitr::kable(
    col.names = c("Variables", "Description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

This allows for structuring of processed data to be ready for indicator estimation and indicator mapping (for S3M).

### Spread a vector of categorial values into columns of unique variables

```r
################################################################################
#
#'
#' Convert character vector of categorical responses into unique variables
#' 
#' Function transforms a vector of categorical responses into `n` number of
#' new columns/variables equal to the number of unique categorical values.
#' 
#' @param x Vector of categorical values 
#' @param prefix A character string to prepend to the names of the new columns
#'   to be created
#' 
#'  
#'
#
################################################################################

spread_vector_to_columns <- function(x, fill = NULL, na_rm = FALSE, prefix) {
  values <- sort(unique(x), na.last = NA)
  
  if (!is.null(fill)) {
    values <- c(values, fill[!fill %in% values]) |>
      sort(na.last = NA)
  }
  
  if (na_rm) {
    values <- c(values, NA_integer_)
  }
  
  values <- values |>
    stringr::str_replace_all(
      pattern = " ", replacement = "_"
    )
  
  col_names <- paste(prefix, values, sep = "_")
  
  lapply(
    X = x,
    FUN = function(x, y) ifelse(x == y, 1, 0),
    y = values
  ) |>
    (\(x) do.call(rbind, x))() |>
    data.frame() |>
    (\(x) { names(x) <- col_names; x })()
}
```

This is a helper function to convert a vector of values into columns of new variables, each recoded into 1 or 0 based on interviewee response.

### Split a vector of select multiple values into columns of new variables

```r
################################################################################
#
#'
#' Split a vector of values from an ODK select multiple type of response
#'
#' This function operates on a single vector of select multiple type of
#' response. This is meant to be used within the `split_select_multiples()`
#' function below.
#'
#
################################################################################

split_select_multiple <- function(x, fill, na_rm = FALSE, prefix) {
  if (na_rm) {
    if (is.na(x)) {
      rep(NA_integer_, times = length(fill)) |>
        (\(x) { names(x) <- paste0(prefix, "_", fill); x })()
    } else {
      stringr::str_split(x, pattern = " ") |> 
        unlist() |> 
        as.integer() |> 
        spread_vector_to_columns(fill = fill, prefix = prefix) |>
        colSums(na.rm = TRUE)
    }
  } else {
    stringr::str_split(x, pattern = " ") |> 
      unlist() |> 
      as.integer() |> 
      spread_vector_to_columns(fill = fill, prefix = prefix) |>
      colSums(na.rm = TRUE)
  }
}
```

```r
################################################################################
#
#'
#' This function vectorises the `split_select_multiple()` across multiple
#' variables.
#'
#
################################################################################

split_select_multiples <- function(x, fill, na_rm = FALSE, prefix) {
  lapply(
    X = x,
    FUN = split_select_multiple,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  ) |>
    dplyr::bind_rows()
}
```

This is a set of helper functions for dealing with select multiple type of responses and the way ODK structures this type of data. The first function applies to a vector of select multiple responses while the second function vectorises this process across multiple vectors.

<br/>

## Indicator set-specific functions

The indicator set-specific functions generally include functions that perform the following sequence of processes:

1. Recode the responses to appropriate values:

    * for binary values of YES or NO; TRUE or FALSE, recode to 1 or 0 accordingly;
    * for categorial values, values are mapped to the values they represent and then spread and/or split into individual columns or variables; and,
    * for values representing NA values, convert to appropriate NA type (NA_integer_ or NA_character_).
    
2. Recode values to specific indicator set-specific definitions.

3. Combine all recode steps and processes within an overall function that recodes an indicator set-specific dataset appropriate for analysis.

Indicator set-specific data processing functions are named with a 2-5 letter code referencing the indicator set followed by the word `recode` and then followed by a descriptor of what type of recoding is being performed. Following are the 2-7 letter prefix for function names per indicator set:

```{r indicator_codes}
indicator_codes <- c(
  "carer", "ccare", "wem", "dev", "fcs", "fies", "fp", "imm", "hygiene", "stock", 
  "hdds", "work", "lcsi", "mddw", "phq", "nc", "net", "pica", "play", "pmtct", 
  "pnet", "preg", "rcsi", "rh", "san", "travel", "vita", "water", "wdds",
  "bf", "fg", "meals", "icfi", "fever", "dia", "rti"
)

indicator_desc <- c(
  "Mother/carer characteristics",
  "Childcare practices",
  "Women's empowerment/decision-making",
  "Child development",
  "Food consumption score",
  "Food insecurity experience scale",
  "Family planning",
  "Childhood immunisation",
  "Hygiene/handwashing",
  "Food stocks",
  "Household dietary diversity score",
  "Income and occupation",
  "Livelihoods coping strategy index",
  "Minimum dietary diversity - women",
  "Primary health questionnaire - 9",
  "Pre- and post-natal care",
  "Mosquito net availability",
  "Pica",
  "Child's play",
  "Prevention of mother-to-child transmission",
  "Mosquito net use during pregnancy",
  "Pregnancy",
  "Reduced coping strategies index",
  "Reproductive health - miscellaneous",
  "Sanitation",
  "Time-to-travel",
  "Vitamin A supplementation",
  "Water",
  "Women's dietary diversity score",
  "ICFI - Breastfeeding",
  "ICFI -  food groups and diet diversity",
  "ICFI - meal frequency",
  "ICFI score",
  "Childhood illnesses - fever",
  "Childhood illnesses - diarrhoea",
  "Childhood illnesses - respiratory tract infection"
)

data.frame(indicator_codes, indicator_desc) |>
  knitr::kable(
    col.names = c("Indicator Codes", "Indicator Description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    full_width = FALSE,
    position = "center",
    font_size = 16
  )
```


### Mother/carer characteristics

```r
################################################################################
#
#'
#' Recode mother characteristics indicators
#' 
#' mother_age	What is your age?
#' resp_marital_status	What is your marital status?
#' resp_edu	How many years of education have you completed?
#' q02	Does your husband/partner actually live in this household?
#' q02a	What is the age of your husband/partner?
#' q02b	What is the highest educational attainment of your husband/partner?
#' q03	For how many years has your family (household) lived in this place?
#'
#
################################################################################

## Recode mother/carer age -----------------------------------------------------

carer_recode_age <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}


## Recode mother/carer marital status ------------------------------------------

carer_recode_marital_status <- function(x, na_values,
                                        status = c("single", "married", 
                                                   "civil_union", 
                                                   "divorced_separated",
                                                   "widowed"),
                                        prefix) {
  x <- ifelse(x %in% na_values, NA, x)
  
  marital_status <- data.frame(
    marital_status = x, 
    spread_vector_to_columns(
      x = x,
      fill = 1:5,
      na_rm = FALSE,
      prefix = prefix
    ) |>
      (\(x) { names(x) <- paste0(prefix, "_", status); x })()
  )
  
  marital_status
}


## Recode mother/carer education achieved --------------------------------------

carer_recode_education <- function(x, na_values,
                                   edu_level = c(paste0("grade", 1:12),
                                                 "professional", "non_college",
                                                 "college", "literacy"),
                                   prefix) {
  x <- ifelse(x %in% na_values, NA, x)
  
  carer_education <- data.frame(
    x, 
    spread_vector_to_columns(
      x = x,
      fill = 1:16,
      na_rm = FALSE,
      prefix = prefix
    ) |>
      (\(x) { names(x) <- paste0(prefix, "_", edu_level); x })()
  )
  
  names(carer_education)[1] <- paste0(prefix, "_education")
  
  carer_education
}


## Overall recode function -----------------------------------------------------

carer_recode <- function(.data, 
                         age_na_values, marital_na_values,
                         education_na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  carer_age <- carer_recode_age(
    x = .data[["mother_age"]], na_values = age_na_values
  )
  
  carer_marital_status <- carer_recode_marital_status(
    x = .data[["resp_marital_status"]], 
    na_values = marital_na_values,
    prefix = "carer"
  )
  
  carer_education <- carer_recode_education(
    x = .data[["resp_edu"]], 
    na_values = education_na_values,
    prefix = "carer"
  )
  
  carer_with_partner <- ifelse(
    .data[["q02"]] %in% c(8, 9), NA,
    ifelse(
      .data[["q02"]] == 2, 0, 1
    )
  )
  
  partner_age <- carer_recode_age(
    x = .data[["q02a"]], na_values = age_na_values
  )
  
  partner_education <- carer_recode_education(
    x = .data[["q02b"]], 
    na_values = education_na_values,
    prefix = "partner"
  )
  
  data.frame(
    core_vars, carer_age, carer_marital_status, carer_education,
    carer_with_partner, partner_age, partner_education
  )
}
```

Complete recoding of the mother/carer characteristics can be performed through a call to the `carer_recode()` function as follows:

```{r carer_function, eval = FALSE, echo = TRUE}
carer_recoded_data = carer_recode(
  .data = raw_data_clean, 
  age_na_values = c(1:14, 88, 99, 100:1000), 
  marital_na_values = c(88, 99),
  education_na_values = c(88, 99)
)
```

which produces a data.frame with the core variables and the following recoded indicator values:

```{r mother_characteristics}
indicators <- c("carer_age", "carer_marital_status", "carer_education", "carer_with_partner", "partner_age", "partner_education")
desc <- c("Age of carer in years", "Marital status of carer", "Highest educational level achieved by carer", "Whether carer lives with spouse/partner", "Age of spouse/partner in years", "Highest educational level achieved by spouse/partner")

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Household dietary diversity score

```r
################################################################################
#
#' 
#' Process and recode household dietary diversity score data/indicators
#' 
#' Relevant variables:
#' 
#'  hdds0 Did the members of your household fast yesterday? 1=Yes; 2=No
#'  
#'  hdds1	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains corn/maize, rice, wheat, sorghum, millet or any 
#'    other grains during the day or night? 1=Yes; 2=No
#'    
#'  hdds2	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains white potatoes, white yam, white cassava, or any 
#'    other roots during the day or night? 1=Yes; 2=No
#'    
#'  hdds3	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains pumpkin, carrot, squash, or sweet potato that are 
#'    orange inside during the day or night?	1=Yes; 2=No
#'
#'  hdds4	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains dark green leafy vegetables, including wild forms 
#'    during the day or night? 1=Yes; 2=No
#'
#'  hdds5	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains other vegetables (e.g. tomato, onion, eggplant) 
#'    during the day or night?	1=Yes; 2=No
#'
#'  hdds6	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains ripe mango, cantaloupe, apricot (fresh or dried), 
#'    ripe papaya, dried peach, and 100% fruit juice made from these during the 
#'    day or night?	1=Yes; 2=No
#'
#'  hdds7	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains other fruits, including wild fruits and 100% fruit 
#'    juice made from these during the day or night? 1=Yes; 2=No
#'
#'  hdds8	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains liver, kidney, heart or other organ meats or 
#'    blood-based foods during the day or night?	1=Yes; 2=No
#'
#'  hdds9	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains beef, pork, lamb, goat, rabbit, game, chicken, 
#'    duck, other birds, insects during the day or night? 1=Yes; 2=No
#'
#'  hdds10 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains eggs from chicken, duck, guinea fowl or any other 
#'    egg during the day or night? 1=Yes; 2=No
#'
#'  hdds11 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains fresh or dried fish or shellfish during the day or 
#'    night? 1=Yes; 2=No
#'
#'  hdds12 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains dried beans, dried peas, lentils, nuts, seeds or 
#'    foods made from these (eg. hummus, peanut butter) during the day or night?
#'    1=Yes; 2=No
#'
#'  hdds13 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains milk, cheese, yogurt or other milk products during 
#'    the day or night? 1=Yes; 2=No
#'
#'  hdds14 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains oil, fats or butter added to food or used for cooking 
#'    during the day or night? 1=Yes; 2=No
#'
#'  hdds15 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains sugar, honey, sweetened soda or sweetened juice 
#'    drinks, sugary foods such as chocolates, candies, cookies and cakes during 
#'    the day or night? 1=Yes; 2=No
#'
#'  hdds16 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains spices (black pepper, salt), condiments 
#'    (soy sauce, hot sauce), coffee, tea, alcoholic beverages during the day 
#'    or night? 1=Yes; 2=No
#'    
#' @param vars A vector of variables to use or a list of vectors of variables
#'   to use for HDDS
#' @param .data A data.frame from which variables should be taken
#' @param food_group A character value specifying food group to recode. Can be
#'   one of 12 food groups used in calculating the HDDS
#'    
#'    
#
################################################################################

## Recode a variable/set of variables for a specific food group ----------------

hdds_recode_group <- function(vars,
                              .data,
                              food_group = c("cereals", "tubers", "vegetables", 
                                             "fruits", "meat", "eggs", "fish",
                                             "legumes_seeds", "milk", "oils_fats",
                                             "sweets", "spices")) {
  food_group <- match.arg(food_group)
  
  if (length(vars) > 1) {
    if (!food_group %in% c("vegetables", "fruits", "meat")) {
      warning(
        paste0(
          "More than one food group variable specified. Please make sure that
          these variables are specific for the ", food_group, " food group."
        )
      )
    } 
    
    ## Get variables
    df <- .data[vars]
    
    ## Recode each variable to 1 and 0
    for (i in vars) {
      df[i] <- recode_yes_no(df[[i]], na_values = c("8", "9"))
    }
    
    ## Recode food group to 1 and 0
    fg <- recode_yes_no(x = rowSums(df, na.rm = TRUE), detect = "no")
  } else {
    if (food_group %in% c("vegetables", "fruits", "meat")) {
      warning(
        paste0(
          "Only one food group variable specified. Please make sure that
          there are no other variables that are specific for the ", food_group, 
          " food group."
        )
      )
    }    
    
    ## Calculate indicator
    fg <- recode_yes_no(.data[[vars]], na_values = c("8", "9"))
  }
  
  ## Return
  fg
}


## Recode multiple variables across multiple food groups -----------------------

hdds_recode_groups <- function(vars,
                               .data,
                               food_group = c("cereals", "tubers", "vegetables", 
                                              "fruits", "meat", "eggs", "fish",
                                              "legumes_seeds", "milk", "oils_fats",
                                              "sweets", "spices")) {
  .data_list <- rep(list(.data), 12)
  
  ## Check that length of vars is the same as length of food_group
  if (length(vars) != length(food_group)) {
    stop(
      "Number of variables/variable groups not the same as the number of
      specified food groups. Please verify specified variables."
    )
  }

  Map(
    f = hdds_recode_group, 
    vars = vars, 
    .data = .data_list, 
    food_group = food_group
  ) |>
    (\(x) { names(x) <- paste0("hdds_", food_group); x })() |>
    dplyr::bind_rows()
  
}


################################################################################
#
#'
#' Create named list of food group variables
#'
#
################################################################################

hdds_map_fg_vars <- function(cereals, tubers, vegetables, fruits, meat, 
                             eggs, fish, legumes_seeds, milk, oils_fats,
                             sweets, spices) {
  list(
    cereals = cereals,
    tubers = tubers,
    vegetables = vegetables,
    fruits = fruits,
    meat = meat,
    eggs = eggs,
    fish = fish,
    legumes_seeds = legumes_seeds,
    milk = milk,
    oils_fats = oils_fats,
    sweets = sweets,
    spices = spices
  )
} 


################################################################################
#
#'
#' Calculate HDDS
#'
#' @param fg_df A data.frame with 12 columns, one for each food group in HDDS
#' @param add Logical. Should the resulting score be added to fg_df? Default to
#'   TRUE
#' 
#'
#
################################################################################

hdds_calculate_score <- function(fg_df, add = TRUE) {
  ## Check that fg_df has 12 columns
  if (ncol(fg_df) != 12) {
    stop(
      "The food group data.frame needs to have 12 columns for each of the
      HDDS food groups. Please verify your dataset."
    )
  }
  
  hdds <- rowSums(fg_df, na.rm = TRUE)
  
  if (add) {
    data.frame(
      fg_df,
      hdds = hdds
    )
  } else {
    hdds
  }
}


hdds_recode <- function(vars,
                        .data,
                        food_group = c("cereals", "tubers", "vegetables", 
                                       "fruits", "meat", "eggs", "fish",
                                       "legumes_seeds", "milk", "oils_fats",
                                       "sweets", "spices")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- hdds_recode_groups(
    vars = vars, .data = .data, food_group = food_group
  ) |>
    hdds_calculate_score(add = TRUE)
  
  data.frame(core_vars, recoded_vars)
}
```

The first three functions above aid in recoding various household dietary diversity score food groups (12 in total) accordingly. The third function helps in mapping the food intake variables in the dataset to the specific food group that they belong to for use in the first 2 functions.

Once a food group data.frame has been created using the first 3 functions, the fourth function is used to calculate the HDDS based on the official FAO guidance[^2]. The final function performs the overall recode for HDDS and concatenates the food groups data.frame with the HDDS along with the core variables.

To get the final recoded HDDS dataset, the following call is performed:

```{r hdds_function, eval = FALSE, echo = TRUE}
## Household dietary diversity score variables
hdds_vars_map <- hdds_map_fg_vars(
  cereals = "hdds1", 
  tubers = "hdds2", 
  vegetables = c("hdds3", "hdds4", "hdds5"), 
  fruits = c("hdds6", "hdds7"), 
  meat = c("hdds8", "hdds9"), 
  eggs = "hdds10", fish = "hdds11", 
  legumes_seeds = "hdds12", 
  milk = "hdds13", 
  oils_fats = "hdds14", 
  sweets = "hdds15", 
  spices = "hdds16"
)

## Create the recoded HDDS dataset
hdds_recoded_data <- hdds_recode(vars = hdds_vars_map, .data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded HDDS indicator values:

```{r hdds_indicators}
indicators <- c(paste0("hdds_", c("cereals", "tubers", "vegetables", "fruits", "meat", "eggs", "fish", "legumes_seeds", "milk", "oils_fats", "sweets", "spices")), "hdds")
desc <- c(
  "HDDS cereals food group", "HDDS tubers food group", "HDDS vegetables food group", "HDDS fruits food group", "HDDS meat food group", "HDDS eggs food group", "HDDS fish food group", "HDDS legumes and seeds food group", "HDDS milk food group", "HDDS oils and fats food group", "HDDS sweets food group", "HDDS spices food group", "Household dietary diversity score" 
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Food consumption score

```r
################################################################################
#
#' 
#' Process and recode Food Consumption Score (FCS) data/indicators
#'
#' Relevant variables:
#'
#'   fcs0 - Did the members of your household fast in the last 7 days?
#'
#'     1=Yes; 2=No
#'
#'   fcs1	How many days in the past week/7 days has your household eaten 
#'     **maize** or any food made from or contains **maize**?
#'
#'   fcs2	How many days in the past week/7 days has your household eaten 
#'     **rice** or any food made from or contains **rice**?
#'
#'   fcs3	How many days in the past week/7 days has your household eaten 
#'     **bread** or any food made from or contains **wheat**?
#'
#'   fcs4	How many days in the past week/7 days has your household eaten 
#'     **tubers** or any food made from or contains **tubers**?
#'
#'   fcs5	How many days in the past week/7 days has your household eaten 
#'     **groundnuts and/or pulses** or any food made from or contains 
#'     **groundnuts and/or pulses**?
#'
#'   fcs6	How many days in the past week/7 days has your household eaten 
#'     **fish** or any food made from or contains **fish**?
#'
#'   fcs7	How many days in the past week/7 days has your household eaten 
#'     **fish powder or fish sauce used as flavouring** or any food made 
#'     from or contains **fish powder or fish sauce as flavouring**?	
#'
#'   fcs8	How many days in the past week/7 days has your household eaten 
#'     **red meat from sheep, goat, or beef** or any food made from or 
#'     contains **red meat from sheep, goat, or beef**?
#'
#'   fcs9	How many days in the past week/7 days has your household eaten 
#'     **white meat from poultry** or any food made from or contains 
#'     **white meat from poultry**?
#'
#'   fcs10	How many days in the past week/7 days has your household eaten 
#'     **vegetable oil and fats** or any food made from or contains 
#'     **vegetable oil and fats**?
#'
#'   fcs11	How many days in the past week/7 days has your household eaten 
#'     **eggs** or any food made from or contains **eggs**?
#'
#'   fcs12	How many days in the past week/7 days has your household eaten 
#'     **milk and dairy products** as a main food?
#'
#'   fcs13	How many days in the past week/7 days has your household taken 
#'     **milk in tea in small amounts**?
#'
#'   fcs14	How many days in the past week/7 days has your household eaten 
#'     **vegetables including leaves** or any food made from or contains 
#'     **vegetables including leaves**?
#'
#'   fcs15	How many days in the past week/7 days has your household eaten 
#'     **fruits** or any food made from or contains **fruits**?
#'
#'   fcs16	How many days in the past week/7days has your household eaten 
#'     **sweets and sugary foods** or any food made from or contains 
#'     **sugar**?
#'     
#' @param vars A vector of variables to use or a list of vectors of variables
#'   to use for FCS
#' @param .data A data.frame from which variables should be taken
#' @param food_group A character value specifying food group to recode. Can be
#'   one of 9 food groups used in calculating the HDDS
#'     
#
################################################################################

## Recode a variable or a set of variables for a specific FCS food group -------

fcs_recode_group <- function(vars, 
                             .data, 
                             food_group = c("staples", "pulses", "vegetables",
                                            "fruits", "meat_fish", "milk",
                                            "sugar", "oil", "condiments")) {
  food_group <- match.arg(food_group)
  
  if (length(vars) > 1) {
    if (!food_group %in% c("staples", "meat_fish", "condiments")) {
      warning(
        paste0(
          "More than one food group variable specified. Please make sure that
          these variables are specific for the ", food_group, " food group."
        )
      )
    } 
    
    ## Get variables
    df <- .data[vars]
    
    ## Recode each variable to 1 and 0
    for (i in vars) {
      df[i] <- ifelse(df[[i]] %in% c("88", "99"), NA, df[[i]])
    }
    
    ## Recode food group to 1 and 0
    fg <- rowSums(df, na.rm = TRUE) |>
      (\(x) ifelse(x > 7, 7, x))() |>
      as.integer()
  } else {
    if (food_group %in% c("staples", "meat_fish", "condiments")) {
      warning(
        paste0(
          "Only one food group variable specified. Please make sure that
          there are no other variables that are specific for the ", food_group, 
          " food group."
        )
      )
    }    
    
    ## Calculate indicator
    fg <- ifelse(.data[[vars]] %in% c("88", "99"), NA, .data[[vars]]) |>
      (\(x) ifelse(x > 7, 7, x))() |>
      as.integer()
  }
  
  ## Return
  fg
}

## Recode multiple sets of variables for multiple FCS food groups --------------

fcs_recode_groups <- function(vars,
                              .data,
                              food_group = c("staples", "pulses", "vegetables",
                                             "fruits", "meat_fish", "milk",
                                             "sugar", "oil", "condiments")) {
  .data_list <- rep(list(.data), 9)
  
  ## Check that length of vars is the same as length of food_group
  if (length(vars) != length(food_group)) {
    stop(
      "Number of variables/variable groups not the same as the number of
      specified food groups. Please verify specified variables."
    )
  }
  
  Map(
    f = fcs_recode_group, 
    vars = vars, 
    .data = .data_list, 
    food_group = food_group
  ) |>
    (\(x) { names(x) <- food_group; x })() |>
    dplyr::bind_rows()
  
}

## Map variables from dataset to each FCS food group

fcs_map_fg_vars <- function(staples, pulses, vegetables,
                            fruits, meat_fish, milk,
                            sugar, oil, condiments) {
  list(
    staples = staples,
    pulses = pulses,
    vegetables = vegetables,
    fruits = fruits,
    meat_fish = meat_fish,
    milk = milk,
    sugar = sugar,
    oil = oil,
    condiments = condiments
  )
}


################################################################################
#
#'
#' Calculate FCS
#'
#' @param fg_df A data.frame with 9 columns, one for each food group in FCS
#' @param add Logical. Should the resulting score be added to fg_df? Default to
#'   TRUE
#' 
#'
#
################################################################################

fcs_calculate_score <- function(fg_df, add = TRUE, 
                                weights = c(2, 3, 1, 1, 4, 4, 0.5, 0.5, 0)) {
  weights <- weights |>
    lapply(
      FUN = rep,
      times = nrow(fg_df)
    ) |>
    (\(x) { names(x) <- paste0("w", 1:length(weights)); x })() |>
    dplyr::bind_cols()
  
  fg_df_weighted <- fg_df * weights
  
  fcs <- rowSums(fg_df_weighted, na.rm = TRUE)
  
  if (add) {
    data.frame(
      fg_df,
      fcs = fcs
    )
  } else {
    fcs
  }
}


################################################################################
#
#'
#' Classify FCS
#' 
#' @param fcs A vector of food consumption scores
#' @param add Logical. Should classification be column binded to fcs? Default
#'   to FALSE.
#' @param spread Logical. Should classification be spread into columns?
#'   Default to FALSE.
#'
#
################################################################################

fcs_classify <- function(fcs, add = FALSE, spread = FALSE, cutoff = c(21, 35)) {
  fcs_class <- cut(
    x = fcs,
    breaks = c(0, cutoff[1], cutoff[2], Inf),
    labels = c("poor", "borderline", "acceptable"),
    include.lowest = FALSE, right = TRUE
  )
  
  if (spread) {
    fcs_class <- data.frame(
      fcs_class = fcs_class,
      spread_vector_to_columns(x = fcs_class, prefix = "fcs")
    )
  }
  
  if (add) {
    fcs_class <- data.frame(
      fcs, fcs_class
    )
  }
  
  fcs_class
}

## Overall FCS recode function -------------------------------------------------


fcs_recode <- function(vars,
                       .data,
                       food_group = c("staples", "pulses", "vegetables",
                                      "fruits", "meat_fish", "milk",
                                      "sugar", "oil", "condiments")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- fcs_recode_groups(
    vars = vars, .data = .data, food_group = food_group
  )
  
  recoded_vars |>
    fcs_calculate_score(add = FALSE) |>
    fcs_classify(add = TRUE, spread = TRUE) |>
    (\(x) data.frame(core_vars, recoded_vars, x))()
}
```

The first three functions above aid in recoding various food consumption score food groups (9 in total) accordingly. The third function helps in mapping the food intake variables in the dataset to the specific food group that they belong to for use in the first 2 functions.

Once a food group data.frame has been created using the first 3 functions, the fourth function is used to calculate the weighted FCS based on the official WFP guidance[^3]. The final function performs the overall recode for FCS and concatenates the food groups data.frame with the FCS and the FCS food insecurity classification along with the core variables.

To get the final recoded FCS dataset, the following call is performed:

```{r fcs_function, eval = FALSE, echo = TRUE}
## Food consumption score
fcs_vars_map <- fcs_map_fg_vars(
  staples = paste0("fcs", 1:4), 
  pulses = "fcs5", 
  vegetables = "fcs14", 
  fruits = "fcs15", 
  meat_fish = paste0("fcs", c(6, 8:9, 11)), 
  milk = "fcs12", 
  sugar = "fcs16", 
  oil = "fcs10", 
  condiments = paste0("fcs", c(7, 13))
)

fcs_recoded_data <- fcs_recode(vars = fcs_vars_map, .data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded FCS indicator values:

```{r fcs_indicators}
indicators <- c(paste0("fcs_", c("staples", "pulses", "vegetables", "fruits", "meat_fish", "milk", "sugar", "oil", "condiments")), "fcs", "fcs_class", "fcs_poor", "fcs_borderline", "fcs_acceptable")

desc <- c(
  "FCS staples food group", 
  "FCS pulses food group",
  "FCS vegetables food group",
  "FCS fruits food group",
  "FCS meat and fish food group",
  "FCS milk food group",
  "FCS sugary food group",
  "FCS oils food group",
  "FCS condiments food group",
  "Food consumption score",
  "Food consumption score food security classification",
  "Food consumption score - poor classification",
  "Food consupmtion score - borderline classification",
  "Food consumption score - acceptable classification"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Reduced coping strategies index

```r
################################################################################
#
#' 
#' Process and recode reduced coping strategy index (rCSI) data/indicators
#'
#' Relevant variables:
#'
#' How many times in the past week have you had to:
#'
#'   rcsi1	Rely on less preferred and less expensive foods? 
#'     88=Don't know; 99=No response
#'
#'   rcsi2	Borrow food, or rely on help from a friend or relative?
#'     88=Don't know; 99=No response
#'
#'   rcsi3 Limit portion size at mealtimes?
#'     88=Don't know; 99=No response
#'
#'   rcsi4	Restrict consumption by adults in order for small children to eat?
#'     88=Don't know; 99=No response
#'
#'   rcsi5	Reduce number of meals eaten in a day?
#'     88=Don't know; 99=No response
#'     
#
################################################################################

## Recode response to a specific coping strategy -------------------------------

rcsi_recode_strategy <- function(x, na_values = NA) {
  if (any(!is.na(na_values))) {
    ifelse(
      x %in% na_values, NA,
      ifelse(
        x > 7, 7, x
      )
    )
  } else {
    ifelse(x > 7, 7, x)
  }
}

## Recode responses to multiple coping strategies ------------------------------

rcsi_recode_strategies <- function(vars, .data, na_values = NA) {
  .data <- .data[vars]
  
  apply(
    X = .data,
    MARGIN = 2,
    FUN = rcsi_recode_strategy,
    na_values = na_values
  ) |>
    data.frame()
}


################################################################################
#
#'
#' Calculate rCSI
#'
#
################################################################################

rcsi_calculate_index <- function(rcsi_df, add = TRUE, 
                                 weights = c(1, 2, 1, 3, 1)) {
  weights <- weights |>
    lapply(
      FUN = rep,
      times = nrow(rcsi_df)
    ) |>
    (\(x) { names(x) <- paste0("w", 1:length(weights)); x })() |>
    dplyr::bind_cols()
  
  rcsi_df_weighted <- rcsi_df * weights
  
  rcsi <- rowSums(rcsi_df_weighted, na.rm = TRUE)
  
  if (add) {
    data.frame(
      rcsi_df,
      rcsi = rcsi
    )
  } else {
    rcsi
  }
}


################################################################################
#
#'
#' Classify rCSI into phases
#'
#
################################################################################

rcsi_classify <- function(rcsi, add = FALSE, spread = FALSE, 
                          phase = 3, cutoff = c(3, 18, 42)) {
  breaks <- c(0, cutoff[1:(phase - 1)], Inf)
  labels <- paste0("phase", 1:phase)
    
  rcsi_class <- cut(
    x = rcsi,
    breaks = breaks,
    labels = labels,
    include.lowest = TRUE, right = TRUE
  )
  
  if (spread) {
    rcsi_class <- data.frame(
      rcsi_class = rcsi_class,
      spread_vector_to_columns(x = rcsi_class, prefix = "rcsi")
    )
  }
  
  if (add) {
    rcsi_class <- data.frame(
      rcsi, rcsi_class
    )
  }
  
  rcsi_class
}


################################################################################
#
#'
#' Overall recode function
#'
#
################################################################################

rcsi_recode <- function(vars,
                       .data,
                       na_values = NA,
                       phase = 3,
                       cutoff = c(3, 18, 42)) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- rcsi_recode_strategies(
    vars = vars, .data = .data, na_values = na_values
  )
  
  recoded_vars |>
    rcsi_calculate_index(add = FALSE) |>
    rcsi_classify(add = TRUE, spread = TRUE, phase = phase, cutoff = cutoff) |>
    (\(x) data.frame(core_vars, recoded_vars, x))()
}

```

The first two functions recodes the different strategies based on reported frequencies with possible values of up to 7 per strategy. The third function then calculates the reduced coping strategies index using the specified weights and according to official WFP guidance[^4]. The fourth function classifies the weighted rCSI into corresponding food insecurity phases. The final function performs the overall recode for rCSI and concatenates the strategies data.frame with the rCSI and the rCSI classification along with the core variables.

To get the final recoded rCSI dataset, the following call is performed:

```{r, rcsi_function, eval = FALSE, echo = TRUE}
## Reduced coping strategies index (rCSI)
rcsi_recoded_data = rcsi_recode(
  vars = paste0("rcsi", 1:5),
  .data = raw_data_clean,
  na_values = c(88, 99)
)
```

which produces a data.frame with the core variables and the following recoded rCSI indicator values:

```{r rcsi_indicators}
indicators <- c(paste0("rcsi", 1:5), "rcsi", "rcsi_class", "rcsi_phase1", "rcsi_phase2", "rcsi_phase3")

desc <- c(
  "rCSI coping strategy 1", 
  "rCSI coping strategy 2",
  "rCSI coping strategy 3",
  "rCSI coping strategy 4",
  "rCSI coping strategy 5",
  "Reduced coping strategy index",
  "rCSI food insecurity phase classification",
  "rCSI phase 1 - minimal/none",
  "rCSI phase 2 - stressed",
  "rCSI phase 3 - crisis"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Women's dietary diversity score

```r
################################################################################
#
#'
#' Recode WDDS
#'
#
################################################################################

## Recode a variable or set of variables to a specific food group --------------

wdds_recode_group <- function(vars,
                              .data,
                              food_group = c("staples", "grean_leafy", 
                                             "other_vita", "fruits_vegetables", 
                                             "organ_meat", "meat_fish", "eggs", 
                                             "legumes", "milk")) {
  food_group <- match.arg(food_group)
  
  if (length(vars) > 1) {
    if (!food_group %in% c(
      "staples", "other_vita", "fruits_vegetables", "meat_fish", "legumes")
    ) {
      warning(
        paste0(
          "More than one food group variable specified. Please make sure that
          these variables are specific for the ", food_group, " food group."
        )
      )
    } 
    
    ## Get variables
    df <- .data[vars]
    
    ## Recode each variable to 1 and 0
    for (i in vars) {
      df[i] <- recode_yes_no(df[[i]], na_values = c("8", "9"))
    }
    
    ## Recode food group to 1 and 0
    fg <- recode_yes_no(x = rowSums(df, na.rm = TRUE), detect = "no") |>
      (\(x) { names(x) <- NULL; x })()
  } else {
    if (food_group %in% c(
      "staples", "other_vita", "fruits_vegetables", "meat_fish", "legumes")
    ) {
      warning(
        paste0(
          "Only one food group variable specified. Please make sure that
          there are no other variables that are specific for the ", food_group, 
          " food group."
        )
      )
    }    
    
    ## Calculate indicator
    fg <- recode_yes_no(.data[[vars]], na_values = c("8", "9"))
  }
  
  ## Return
  fg
}

## Recode variables for multiple foods groups ----------------------------------

wdds_recode_groups <- function(vars,
                               .data,
                               food_group = c("staples", "grean_leafy", 
                                              "other_vita", "fruits_vegetables", 
                                              "organ_meat", "meat_fish", "eggs", 
                                              "legumes", "milk")) {
  .data_list <- rep(list(.data), 9)
  
  ## Check that length of vars is the same as length of food_group
  if (length(vars) != length(food_group)) {
    stop(
      "Number of variables/variable groups not the same as the number of
      specified food groups. Please verify specified variables."
    )
  }
  
  Map(
    f = wdds_recode_group, 
    vars = vars, 
    .data = .data_list, 
    food_group = food_group
  ) |>
    (\(x) { names(x) <- paste0("wdds_", food_group); x })() |>
    dplyr::bind_rows()

}



################################################################################
#
#'
#' Create named list of food group variables
#'
#
################################################################################

wdds_map_fg_vars <- function(staples, grean_leafy, other_vita, 
                             fruits_vegetables, organ_meat, meat_fish, 
                             eggs, legumes, milk) {
  list(
    staples = staples, 
    grean_leafy = grean_leafy, 
    other_vita = other_vita, 
    fruits_vegetables = fruits_vegetables, 
    organ_meat = organ_meat, 
    meat_fish = meat_fish, 
    eggs = eggs, 
    legumes = legumes, 
    milk = milk
  )
} 



################################################################################
#
#'
#' Calculate WDDS
#'
#' @param fg_df A data.frame with 9 columns, one for each food group in WDDS
#' @param add Logical. Should the resulting score be added to fg_df? Default to
#'   TRUE
#' 
#'
#
################################################################################

wdds_calculate_score <- function(fg_df, add = TRUE) {
  ## Check that fg_df has 9 columns
  if (ncol(fg_df) != 9) {
    stop(
      "The food group data.frame needs to have 9 columns for each of the
      HDDS food groups. Please verify your dataset."
    )
  }
  
  wdds <- rowSums(fg_df, na.rm = TRUE)
  
  if (add) {
    data.frame(
      fg_df,
      wdds = wdds
    )
  } else {
    wdds
  }
}

## Overall WDDS recode function ------------------------------------------------

wdds_recode <- function(vars,
                        .data,
                        food_group = c("staples", "grean_leafy", 
                                       "other_vita", "fruits_vegetables", 
                                       "organ_meat", "meat_fish", "eggs", 
                                       "legumes", "milk")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- wdds_recode_groups(
    vars = vars, .data = .data, food_group = food_group
  ) |>
    wdds_calculate_score(add = TRUE)
  
  data.frame(core_vars, recoded_vars)
}

```

The first three functions above aid in recoding various women's dietary diversity score food groups (9 in total) accordingly. The third function helps in mapping the food intake variables in the dataset to the specific food group that they belong to for use in the first 2 functions.

Once a food group data.frame has been created using the first 3 functions, the fourth function is used to calculate the WDDS based on the official FAO guidance[^2]. The final function performs the overall recode for WDDS and concatenates the food groups data.frame with the WDDS along with the core variables.

To get the final recoded WDDS dataset, the following call is performed:

```{r wdds_function, eval = FALSE, echo = TRUE}
## Women's dietary diversity score (WDDS)
wdds_vars_map <- wdds_map_fg_vars(
  staples = c("nutmul1", "nutmul2"),
  grean_leafy = "nutmul10",
  other_vita = c("nutmul11", "nutmul12"),
  fruits_vegetables = c("nutmul13", "nutmul14"),
  organ_meat = "nutmul6",
  meat_fish = c("nutmul7", "nutmul8"),
  eggs = "nutmul9",
  legumes = c("nutmul3", "nutmul4"),
  milk = "nutmul5"
)

wdds_recoded_data <- wdds_recode(vars = wdds_vars_map, .data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded WDDS indicator values:

```{r wdds_indicators}
indicators <- c(paste0("wdds_", c("staples", "green_leafy", "other_vita", "fruits_vegetables", "organ_meat", "meat_fish", "eggs", "legumes", "milk")), "wdds")

desc <- c(
  "WDDS staples food group", "WDDS green and leafy vegetables food group", "WDDS other vitamin A-rich food group", "WDDS fruits and vegetables food group", "WDDS organ meat food group", "WDDS meat and fish food group", "WDDS eggs food group", "WDDS legumes and seeds food group", "WDDS milk food group", "Women's dietary diversity score" 
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Minimum dietary diversity - women

```r
################################################################################
#
#'
#' Recode MDD-W
#'
#
################################################################################

## Recode variable or set of variables for a specific food group ---------------

mddw_recode_group <- function(vars,
                              .data,
                              food_group = c("staples", "pulses", "nuts_seeds", 
                                             "milk", "meat_fish", "eggs",
                                             "green_leafy", "other_vita",
                                             "vegetables", "fruits")) {
  food_group <- match.arg(food_group)
  
  if (length(vars) > 1) {
    if (!food_group %in% c("staples", "other_vita", "meat_fish")) {
      warning(
        paste0(
          "More than one food group variable specified. Please make sure that
          these variables are specific for the ", food_group, " food group."
        )
      )
    } 
    
    ## Get variables
    df <- .data[vars]
    
    ## Recode each variable to 1 and 0
    for (i in vars) {
      df[i] <- recode_yes_no(df[[i]], na_values = c("8", "9"))
    }
    
    ## Recode food group to 1 and 0
    fg <- recode_yes_no(x = rowSums(df, na.rm = TRUE), detect = "no") |>
      (\(x) { names(x) <- NULL; x })()
  } else {
    if (food_group %in% c("staples", "other_vita", "meat_fish")) {
      warning(
        paste0(
          "Only one food group variable specified. Please make sure that
          there are no other variables that are specific for the ", food_group, 
          " food group."
        )
      )
    }    
    
    ## Calculate indicator
    fg <- recode_yes_no(.data[[vars]], na_values = c("8", "9"))
  }
  
  ## Return
  fg
}

## Recode variables for multiple food groups -----------------------------------

mddw_recode_groups <- function(vars,
                               .data,
                               food_group = c("staples", "pulses", "nuts_seeds", 
                                              "milk", "meat_fish", "eggs",
                                              "green_leafy", "other_vita",
                                              "vegetables", "fruits")) {
  .data_list <- rep(list(.data), 10)
  
  ## Check that length of vars is the same as length of food_group
  if (length(vars) != length(food_group)) {
    stop(
      "Number of variables/variable groups not the same as the number of
      specified food groups. Please verify specified variables."
    )
  }
  
  Map(
    f = mddw_recode_group, 
    vars = vars, 
    .data = .data_list, 
    food_group = food_group
  ) |>
    (\(x) { names(x) <- paste0("mddw_", food_group); x })() |>
    dplyr::bind_rows()

}


################################################################################
#
#'
#' Create named list of food group variables
#'
#
################################################################################

mddw_map_fg_vars <- function(staples, pulses, nuts_seeds, milk, meat_fish, 
                             eggs, green_leafy, other_vita, vegetables, 
                             fruits) {
  list(
    staples = staples,
    pulses = pulses,
    nuts_seeds = nuts_seeds,
    milk = milk,
    meat_fish = meat_fish, 
    eggs = eggs, 
    green_leafy = green_leafy,
    other_vita = other_vita,
    vegetables = vegetables,
    fruits = fruits
  )
} 



################################################################################
#
#'
#' Calculate MDDW
#'
#' @param fg_df A data.frame with 10 columns, one for each food group in WDDS
#' @param add Logical. Should the resulting score be added to fg_df? Default to
#'   TRUE
#' 
#'
#
################################################################################

mddw_calculate_score <- function(fg_df, add = TRUE) {
  ## Check that fg_df has 10 columns
  if (ncol(fg_df) != 10) {
    stop(
      "The food group data.frame needs to have 10 variables for each of the
      MDD-W food groups. Please verify your dataset."
    )
  }
  
  mddw <- rowSums(fg_df, na.rm = TRUE)
  
  if (add) {
    data.frame(
      fg_df,
      mddw_score = mddw,
      mddw = ifelse(mddw >= 5, 1, 0)
    )
  } else {
    data.frame(
      mddw_score = mddw,
      mddw = ifelse(mddw >= 5, 1, 0)
    )
  }
}

## Overall MDDW recode function ------------------------------------------------

mddw_recode <- function(vars,
                        .data,
                        food_group = c("staples", "pulses", "nuts_seeds", 
                                       "milk", "meat_fish", "eggs",
                                       "green_leafy", "other_vita",
                                       "vegetables", "fruits")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- mddw_recode_groups(
    vars = vars, .data = .data, food_group = food_group
  ) |>
    mddw_calculate_score(add = TRUE)
  
  data.frame(core_vars, recoded_vars)
}
```

The first three functions above aid in recoding various minimum dietary diversity - women food groups (10 in total) accordingly. The third function helps in mapping the food intake variables in the dataset to the specific food group that they belong to for use in the first 2 functions.

Once a food group data.frame has been created using the first 3 functions, the fourth function is used to calculate the food group score and to recode those women who meet the minimum number of good groups to be classified as having a diverse diet (at least 5 food groups) based on the official FAO guidance[^5]. The final function performs the overall recode for MDD-W and concatenates the food groups data.frame with the MDD-W food groups score and the MDD-W classification along with the core variables.

To get the final recoded MDD-W dataset, the following call is performed:

```{r mddw_function, eval = FALSE, echo = TRUE}
## Minimum dietary diversity - women (MDD-W)
mddw_vars_map <- mddw_map_fg_vars(
  staples = c("nutmul1", "nutmul2"),
  pulses = "nutmul3",
  nuts_seeds = "nutmul4",
  milk = "nutmul5",
  meat_fish = c("nutmul6", "nutmul7", "nutmul8"), 
  eggs = "nutmul9", 
  green_leafy = "nutmul10",
  other_vita = c("nutmul11", "nutmul12"),
  vegetables = "nutmul13",
  fruits = "nutmul14"
)

mddw_recoded_data <- mddw_recode(vars = mddw_vars_map, .data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded MDD-W indicator values:

```{r mddw_indicators}
indicators <- c(paste0("mddw_", c("staples", "pulses", "nuts_seeds", "milk", "meat_fish", "eggs", "green_leafy", "other_vita", "vegetables", "fruits")), "mddw_score", "mddw")

desc <- c(
  "MDD-W staples food group", "MDD-W pulses food group", "MDD-W nuts and seeds food group", "MDD-W milk food group", "MDD-W meat and fish food group", "MDD-W eggs food group", "MDD-W green leafy vegetables food group", "MDD-W other vitamin A-rich food groups", "MDD-W vegetables food group", "MDD-W fruits food group", "MDD-W food groups score", "MDD-W" 
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Livelihoods coping strategy index

```r
################################################################################
#
#'
#' Recode LCSI indicators/data
#'
#
################################################################################

## Recode responses to specific coping strategy --------------------------------

lcsi_recode_strategy <- function(x, na_values) {
  if (any(!is.na(na_values))) {
    ifelse(
      x %in% na_values, NA,
      ifelse(
        x %in% c(1, 4), 1, 0
      )
    )
  } else {
    ifelse(x %in% c(1, 4), 1, 0)
  }
}

## Recode responses to multiple coping strategies ------------------------------

lcsi_recode_strategies <- function(vars, .data, na_values = NA) {
  .data <- .data[vars]
  
  apply(
    X = .data,
    MARGIN = 2,
    FUN = lcsi_recode_strategy,
    na_values = na_values
  ) |>
    data.frame()
}

## Classify a spoecific strategy into appropriate food insecurity phase --------

lcsi_classify_strategy <- function(lcsi, 
                                   phase = c(2, 3, 4, 2, 2, 3, 3, 4, 
                                              2, 4, 3, 2, 3, 3)) {
  if (length(lcsi) != length(phase)) {
    stop(
      "Set of livelihood coping strategies not the same length as the
      phase classifying values. Please check strategies set and/or
      phase classifying values."
    )
  }
  
  (lcsi * phase) |>
    (\(x) ifelse(x == 0, 1, x))() |>
    unlist()
}

################################################################################
#
#'
#' Calculate LCSI
#'
#
################################################################################

lcsi_calculate_index <- function(lcsi_df, add = TRUE,
                                 phase = c(2, 3, 4, 2, 2, 3, 3, 4, 
                                           2, 4, 3, 2, 3, 3)) {
  lcsi <- apply(
    X = lcsi_df,
    MARGIN = 1,
    FUN = lcsi_classify_strategy,
    phase = phase,
    simplify = FALSE
  ) |>
    dplyr::bind_rows()
  
  if (add) {
    data.frame(
      lcsi_df, 
      lcsi = lcsi)
  } else {
    lcsi
  }
}

## Classify based on worst coping strategy used --------------------------------

lcsi_classify <- function(lcsi, add = FALSE, spread = FALSE,
                          phase = c(2, 3, 4, 2, 2, 3, 3, 4, 
                                    2, 4, 3, 2, 3, 3)) {  
  lcsi <- apply(
    X = lcsi,
    MARGIN = 1,
    FUN = max,
    na.rm = TRUE,
    simplify = FALSE
  ) |>
    unlist() |>
    (\(x) ifelse(x == -Inf, NA, x))()
  
  lcsi_class <- lcsi |>
    (\(x) c("secure", "stress", "crisis", "emergency")[x])() |>
    (\(x) factor(x, levels = c("secure", "stress", "crisis", "emergency")))()
    
  if (spread) {
    lcsi_class <- spread_vector_to_columns(
      x = lcsi_class,
      prefix = "lcsi"
    )
  }
  
  if (add) {
    data.frame(lcsi, lcsi_class)
  } else {
    lcsi_class
  }
}


################################################################################
#
#'
#' Overall recode function
#'
#
################################################################################

lcsi_recode <- function(vars,
                        .data,
                        na_values = NA,
                        phase = c(2, 3, 4, 2, 2, 3, 3, 4, 
                                  2, 4, 3, 2, 3, 3)) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- lcsi_recode_strategies(
    vars = vars, .data = .data, na_values = na_values
  )
  
  recoded_vars |>
    lcsi_calculate_index(add = FALSE, phase = phase) |>
    lcsi_classify(add = TRUE, spread = TRUE, phase = phase) |>
    (\(x) data.frame(core_vars, recoded_vars, x))()
}

```

The first two functions above aid in recoding various livelihoods coping strategies employed. The next two functions then classifies each of the recoded responses to the strategies into the four food insecurity phases. The fifth function then takes all the classified strategies and determines the worst food insecurity phase strategy employed as the overall classification. These classifications are based on the official guidelines by WFP[^4]. The final function performs the overall recode for LCSI and concatenates the recoded strategies data.frame with the LCSI classification along with the core variables.

To get the final recoded LCSI dataset, the following call is performed:

```{r lcsi_function, echo = TRUE, eval = FALSE}
## Livelihoods coping strategy index (LCSI)
lcsi_recoded_data <- lcsi_recode(
  vars = c(
    "lcs01", "lcs02", "lcs03", "lcs04", "lcs05", "lcs06", "lcs07", 
    "lcs08", "lcs09", "lcs10", "lcs11", "lcs12", "lcs13", "lcs14"
  ),
  .data = raw_data_clean,
  na_values = c(5, 8, 9)
)
```

which produces a data.frame with the core variables and the following recoded LCSI indicator values:

```{r lcsi_indicators}
indicators <- c(paste0("lcsi", stringr::str_pad(1:14, width = 2, side = "left", pad = "0")), "lsci", "lsci_secure", "lcsi_stress", "lcsi_crisis", "lcsi_emergency")

desc <- c(
  "LCSI coping strategy 1",
  "LCSI coping strategy 2",
  "LCSI coping strategy 3",
  "LCSI coping strategy 4",
  "LCSI coping strategy 5",
  "LCSI coping strategy 6",
  "LCSI coping strategy 7",
  "LCSI coping strategy 8",
  "LCSI coping strategy 9",
  "LCSI coping strategy 10",
  "LCSI coping strategy 11",
  "LCSI coping strategy 12",
  "LCSI coping strategy 13",
  "LCSI coping strategy 14",
  "Livelihoods coping strategy index",
  "LCSI - secure phase",
  "LCSI - stress phase",
  "LCSI - crisis phase",
  "LCSI - emergency phase"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Primary health questionnaire

```r
################################################################################
#
#' 
#' Process and recode mental health data/indicators
#'
#' Relevant variables:
#'
#'   ment1 - In the last two weeks, how many days did you have little interest 
#'     or little happiness in doing things?
#'   
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment2 - In the last two weeks, how many days did you feel down, depresssed 
#'     or without motivation?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment3 - In the last two weeks, how many days did you have difficulty 
#'     sleeping, or staying asleep, or sleeping more than is customary?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment4 - In the last two weeks, how many days did you feel tired or with 
#'     little energy?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment5 - In the last two weeks, how many days did you have lack of appetite 
#'     or ate less?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment6 - In the last two weeks, how many days did you feel bad about 
#'     yourself or thought you were a failure or that you let down your family 
#'     or yourself?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment7 - In the last two weeks, how many days did you have difficulty 
#'     concentrating on things (such as reading a newspaper, watching 
#'     television, or listening to the radio?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   	ment8 - In the last two weeks, how many days did you feel slow in your 
#'      movements or in speaking; or the contrary, in which you felt agitated 
#'      and you stayed walking from one side to another, more than is customary?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   	ment9 - With what frequency do you consume alcoholic beverages?
#'
#'      1=Never; 2=Monthly or less; 3=Between 2-4 times per month; 
#'      4=Between 2-3 times per week; 5=4 or more times per week; 
#'      88=Don&apos;t know; 99=No response
#'      
#
################################################################################

## Recode a specific PHQ symptom -----------------------------------------------

phq_recode_symptom <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x - 1)
}

## Recode multiple PHQ symptoms ------------------------------------------------

phq_recode_symptoms <- function(vars, .data, na_values) {
  .data <- .data[vars]
  
  apply(
    X = .data,
    MARGIN = 2,
    FUN = phq_recode_symptom,
    na_values = na_values
  ) |>
    data.frame()
}

## Calculate PHQ score ---------------------------------------------------------

phq_calculate_score <- function(phq_df, add = TRUE) {
  phq <- rowSums(phq_df, na.rm = TRUE)
  
  if (add) {
    data.frame(
      phq_df,
      phq = phq
    )
  } else {
    phq
  }
  
}

## Classify mental health status based on PHQ score ----------------------------

phq_classify <- function(phq, add = FALSE, spread = FALSE) {
  breaks <- c(1, 4, 9, 14, 19, 27)
  labels <- c("minimal", "mild", "moderate", "moderate severe", "severe")
  
  phq_class <- cut(
    x = phq,
    breaks = breaks,
    labels = labels,
    include.lowest = TRUE, right = TRUE
  ) |>
    as.character() |>
    (\(x) ifelse(is.na(x), "no depression", x))() |>
    factor(
      levels = c(
        "no depression", "minimal", "mild", 
        "moderate", "moderately severe", "severe"
      )
    )
  
  if (spread) {
    phq_class <- data.frame(
      phq_class = phq_class,
      spread_vector_to_columns(x = phq_class, prefix = "rcsi")
    )
  }
  
  if (add) {
    phq_class <- data.frame(
      phq, phq_class
    )
  }
  
  phq_class
}


################################################################################
#
#'
#' Overall recode function
#'
#
################################################################################

phq_recode <- function(vars,
                       .data,
                       na_values = NA) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- phq_recode_symptoms(
    vars = vars, .data = .data, na_values = na_values
  )
  
  recoded_vars |>
    phq_calculate_score(add = FALSE) |>
    phq_classify(add = TRUE, spread = TRUE) |>
    (\(x) data.frame(core_vars, recoded_vars, x))()
}
```

The first two functions facilitates the recoding of responses to each of the symptoms that are asked of the respondent as described by Kroenke et al (2001)[^6]. These recoded responses per symptom are then added to get an overall PHQ score (that can go up to 27) which is performed by the third function above. The fourth function then classifies each respondent's mental health status according to their PHQ score based on guidance described in Kroenke et al (2001)[^6]. The final function performs the overall recode for PHQ and concatenates the recoded symptoms data.frame with the PHQ score and PHQ classification along with the core variables.

To get the final recoded PHQ dataset, the following call is performed:

```{r phq_function, echo = TRUE, eval = FALSE}
## Primary health questionnaire - depression
phq_recoded_data = phq_recode(
  vars = paste0("ment", 1:9),
  .data = raw_data_clean,
  na_values = c(88, 99)
)
```

which produces a data.frame with the core variables and the following recoded PHQ indicator values:

```{r phq_indicators}
indicators <- c(paste0("ment", 1:9), "phq", "phq_class", "phq_no_depression", "phq_minimal", "phq_moderate", "phq_severe")

desc <- c(
  "PHQ symptom 1",
  "PHQ symptom 2",
  "PHQ symptom 3",
  "PHQ symptom 4",
  "PHQ symptom 5",
  "PHQ symptom 6",
  "PHQ symptom 7",
  "PHQ symptom 8",
  "PHQ symptom 9",
  "PHQ score",
  "PHQ classification",
  "PHQ - no depression",
  "PHQ - minimal depression",
  "PHQ - moderate depression",
  "PHQ - severe depression"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Childcare practices

```r
################################################################################
#
#' 
#' Process and recode childcare practices data/indicators
#'
#' Relevant variables:
#'
#'   ccare1 - Can you tell me what symptoms indicate that a child needs 
#'     immediate medical attention?  Please tell me all the symptoms that you 
#'     can. integer variables for the following categorical values:
#' 
#'     1=Fever; 
#'     2=Blood in stool; 
#'     3=Diarrhoea with dehydration (lack of tears/sunken eyes); 
#'     4=Cough, rapid respiration and/or difficulty breathing; 
#'     5=Unable to drink water, breastfeed, or eat; 
#'     6=Vomiting; 
#'     7=Convulsions; 
#'     8=Loss of consciousness; 
#'     9=Fatigue/no response/not wanting to play; 
#'     10=Neck rigidity; 
#'     88=Don't know; 
#'     99=No response
#'
#'   ccare2 - In relation to the child's health issues (e.g., vaccines, care, 
#'     etc.), do you have the support or involvement of the child's father?
#'     integer variables for the following categorical values:
#'     
#'     1=Yes; 
#'     2=No
#'
#'   ccare3 - In your opinion, what are the barriers or difficulties in taking 
#'     a child to receive health care treatment? integer variables for the
#'     following categorical values:
#'   
#'     1=Distance; 
#'     2=Transport; 
#'     3=Money; 
#'     4=Poor treatment at the health facility/hospital; 
#'     5=Other; 
#'     88=Don't know; 
#'     99=No response
#'     
#
################################################################################

## Recode responses to a specific childcare practices question -----------------

ccare_recode_responses <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}

## Recode responses to childcare practices questions on danger sign ------------

ccare_danger_recode <- function(vars, .data, 
                                na_values = c("88", "99"),
                                fill = 1:10, 
                                na_rm = TRUE, 
                                prefix = "ccare_danger",
                                threshold = 8) {
  x <- .data[[vars]]
  
  x <- ccare_recode_responses(x, na_values = na_values)
  
  danger_df <- split_select_multiples(
    x = x, fill = fill, na_rm = na_rm, prefix = prefix
  )
  
  ccare_danger_score <- rowSums(danger_df, na.rm = TRUE) |>
    (\(x) ifelse(x == 0, NA_integer_, x))()
  
  ccare_danger_prop <- ifelse(ccare_danger_score >= threshold, 1, 0)
  
  data.frame(
    danger_df, ccare_danger_score, ccare_danger_prop
  )
}

## Recode responses to childcare practices questions on participation  ---------

ccare_participation_recode <- function(x, na_values) {
  ifelse(
    x %in% na_values, NA,
    ifelse(
      x == 2, 0, 1
    )
  )
}

## Recode responses to childcare practices questions on barriers ---------------

ccare_barriers_recode <- function(vars, .data, 
                                  na_values = c("88", "99"),
                                  fill = 1:5, 
                                  na_rm = TRUE, 
                                  prefix = "ccare_barriers") {
  x <- .data[[vars]]
  
  x <- ccare_recode_responses(x, na_values = na_values)
  
  split_select_multiples(
    x = x, fill = fill, na_rm = na_rm, prefix = prefix
  )
}

## Overall childcare recode ----------------------------------------------------

ccare_recode <- function(.data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- data.frame(
    ccare_danger_recode(vars = "ccare1", .data = .data),
    ccare_participation = ccare_participation_recode(
      x = .data[["ccare2"]], na_values = c(8, 9)
    ),
    ccare_barriers_recode(vars = "ccare3", .data = .data)
  )
  
  data.frame(core_vars, recoded_vars)
}

```

The first function performs recoding of responses to a specific question in the child care practices indicator set. The second function uses the first function to recode responses from questions specific to danger signs to watch out for in children. The third function uses the first function to recode responses from questions specific to participation in child care. The fourth function uses the first function to recode responses from questions specific to barriers to child care. The final function performs the overall recode for child care practices and concatenates the various child care practices indicators with the core variables.

To get the final recoded child care dataset, the following call is performed:

```{r ccare_function, echo = TRUE, eval = FALSE}
## Childcare practices
ccare_recoded_data <- ccare_recode(.data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded child care practices indicator values:

```{r ccare_indicators}
indicators <- c(paste0("ccare_danger_", 1:10), "ccare_danger_score", "ccare_danger_prop", "ccare_participation", paste0("ccare_barriers", 1:5))

desc <- c(
  "Child care danger sign 1",
  "Child care danger sign 2",
  "Child care danger sign 3",
  "Child care danger sign 4",
  "Child care danger sign 5",
  "Child care danger sign 6",
  "Child care danger sign 7",
  "Child care danger sign 8",
  "Child care danger sign 9",
  "Child care danger sign 10",
  "Child care danger sign score",
  "Child care danger sign proportion with score of at least 8",
  "Child care involvement of father",
  "Child care barries 1",
  "Child care barries 2",
  "Child care barries 3",
  "Child care barries 4",
  "Child care barries 5"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Women's empowerment/decision-making

```r
################################################################################
#
# Process and recode decision making data/indicators
#
# Relevant variables:
#
#   ge1 - Appropriate age to marry? integer variables for the following
#     categorical values:
#     
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge2 - Use of condoms? integer variables for the following categorical
#     values:
# 
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge3 - Household responsibilities? integer variables for the following
#     categorical values:
#
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge4 - Family planning - number of childre to have? integer variables for
#     the following categorical values:
# 
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge5 - Family/land chores? integer variables for the following categorical
#     values:
#   
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge6 - Administration of finances (money) in the home? integer variables
#     for the following categorical values:
#
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge7 - How to raise children? integer variables for the following
#     categorical values:
#
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge8 - Hitting/spanking children? integer variables for the following
#     categorical values:
#     
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#   
#   ge9 - Seeking health care for pregnancy?	integer variables for the
#     following categorical values:
#   
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response 
#
#   ge10 - Seeking health care for a child? integer variables for the
#     following categorical values:
# 
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   von1 - Please, how much freedong of choice do you feel you have on what 
#     happens to your life? integer variables for the following categorical
#     values:
#
#     1=No choice; 
#     2=Little choice; 
#     3=Some choice; 
#     4=A lot of choice; 
#     88=Don't know; 
#     99=No response
#
#   von2 - Until what point do you feel you can decide your own destiny?
#     integer variables for the following categorical values:
# 
#     1=Not at all; 
#     2=A little; 
#     3=Enough; 
#     4=A lot; 
#     88=Don't know; 
#     99=No response
#
#   von3	In general, do you think you can make decisions by yourself, freely, 
#     without consulting your husband? Please, to what extent can you do this?
#     integer variables for the following categorical values:
#
#       1=Never; 
#       2=Sometimes; 
#       3=Almost always; 
#       4=Always; 
#       88=Don't know; 
#       99=No response
#
#   von4	Did you accept to participate in this survey of your own volition?
#     integer variables for the following categorical values:
#   
#     1=I accepted to participate voluntarily and freely; 
#     2=Yes, but I need the consent of the male head of household; 
#     3=No, I needed the consent of the male head of household; 
#     4=I need someone else's consent; 
#     88=Don't know; 
#     99=No response
#
################################################################################

## Recode responses to individual questions in indicator set -------------------

wem_recode_response <- function(x, na_values) {
  ifelse(x %in% na_values, NA_integer_, x)
}

## Recode responses to multiple questions in indicator set ---------------------

wem_recode_responses <- function(vars, .data, na_values) {
  vars <- .data[vars]
  
  apply(
    X = vars,
    MARGIN = 2,
    FUN = wem_recode_response,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame() |>
    (\(x) { names(x) <- names(vars); x } )()
}

## Recode responses to a specific decision topic -------------------------------

wem_recode_decision <- function(x, 
                                fill = NULL,
                                na_rm = FALSE,
                                prefix,
                                label = NULL) {
  wem_decision <- spread_vector_to_columns(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
  
  if (!is.null(label)) {
    names(wem_decision) <- paste0(prefix, "_", label)
    wem_decision
  }
  
  data.frame(x, wem_decision) |>
    (\(x) { names(x)[1] <- prefix; x } )()
}

## Recode responses to multiple decision topcis --------------------------------

wem_recode_decisions <- function(vars, .data, na_rm = FALSE, label = NULL) {
  x <- .data[vars]
  
  Map(
    f = wem_recode_decision,
    x = apply(X = x, MARGIN = 2, list) |>
      unlist(recursive = FALSE),
    prefix = vars,
    na_rm = na_rm,
    label = rep(list(label), length(vars))
  ) |>
    dplyr::bind_cols()
}

## Overall women's empowerment recode function

wem_recode <- function(.data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  wem_recoded_vars <- wem_recode_responses(
    vars = c(paste0("ge", 1:10), paste0("von", 1:4)) ,
    .data = .data,
    na_values = c(88, 99)
  ) 
  
  ge_recoded_vars <- wem_recode_decisions(
    vars = paste0("ge", 1:10),
    .data = wem_recoded_vars,
    na_rm = FALSE,
    label = c("men", "women", "both")
  )
  
  von_recoded_vars <- data.frame(
    wem_recode_decisions(
      vars = "von1",
      .data = wem_recoded_vars,
      na_rm = FALSE,
      label = c("no_choice", "little_choice", "some_choice", "lots_choices")
    ),
    von1_some_lots = ifelse(wem_recoded_vars[["von1"]] %in% 3:4, 1, 0),
    wem_recode_decisions(
      vars = "von2",
      .data = wem_recoded_vars,
      na_rm = FALSE,
      label = c("no", "little", "enough", "a_lot")
    ),
    von2_enough_lots = ifelse(wem_recoded_vars[["von2"]] %in% 3:4, 1, 0),
    wem_recode_decisions(
      vars = "von3",
      .data = wem_recoded_vars,
      na_rm = FALSE,
      label = c("never", "sometimes", "almost", "always")
    ),
    von3_almost_always = ifelse(wem_recoded_vars[["von3"]] %in% 3:4, 1, 0),
    wem_recode_decisions(
      vars = "von4",
      .data = wem_recoded_vars,
      na_rm = FALSE,
      label = c("freely", "freely_consent", "husband_consent", "someone_consent")
    ),
    von4_some_freely = ifelse(wem_recoded_vars[["von2"]] %in% 3:4, 0, 1)
  ) 
  
  data.frame(core_vars, ge_recoded_vars, von_recoded_vars)
}
```

The first two functions performs general recoding of the responses to the various questions in this indicator set. The next two functions performs specific recoding of responses to various decision topics. The final function provides overall recoding and concatenates the various women's empowerment indicators with the core variables.

To get the final recoded women's empowerment dataset, the following call is performed:

```{r wem_function, echo = TRUE, eval = FALSE}
## Women's empowerment and decision-makin
wem_recoded_data = wem_recode(raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded women's empowerment indicator values:

```{r wem_indicators}
indicators <- c(
  paste0("ge1", c("", "_men", "_women", "_both")),
  paste0("ge2", c("", "_men", "_women", "_both")),
  paste0("ge3", c("", "_men", "_women", "_both")),
  paste0("ge4", c("", "_men", "_women", "_both")),
  paste0("ge5", c("", "_men", "_women", "_both")),
  paste0("ge6", c("", "_men", "_women", "_both")),
  paste0("ge7", c("", "_men", "_women", "_both")),
  paste0("ge8", c("", "_men", "_women", "_both")),
  paste0("ge9", c("", "_men", "_women", "_both")),
  paste0("ge10", c("", "_men", "_women", "_both")),
  paste0("von1", c("", "_no_choice", "_little_choice", "_some_choice", "_lots_choices", "_some_lots")),
  paste0("von2", c("", "_no", "_little", "_enough", "_a_lot", "_enough_lots")),
  paste0("von3", c("", "_never", "_sometimes", "_almost", "_always", "_almost_always")),
  paste0("von4", c("", "_freely", "_freely_consent", "_husband_consent", "_someone_consent", "_some_freely"))
)

desc <- c(
  "Decision maker for topic 1",
  "Decision maker for topic 1 - men",
  "Decision maker for topic 1 - women",
  "Decision maker for topic 1 - both",
  "Decision maker for topic 2",
  "Decision maker for topic 2 - men",
  "Decision maker for topic 2 - women",
  "Decision maker for topic 2 - both",
  "Decision maker for topic 3",
  "Decision maker for topic 3 - men",
  "Decision maker for topic 3 - women",
  "Decision maker for topic 3 - both",
  "Decision maker for topic 4",
  "Decision maker for topic 4 - men",
  "Decision maker for topic 4 - women",
  "Decision maker for topic 4 - both",
  "Decision maker for topic 5",
  "Decision maker for topic 5 - men",
  "Decision maker for topic 5 - women",
  "Decision maker for topic 5 - both",
  "Decision maker for topic 6",
  "Decision maker for topic 6 - men",
  "Decision maker for topic 6 - women",
  "Decision maker for topic 6 - both",
  "Decision maker for topic 7",
  "Decision maker for topic 7 - men",
  "Decision maker for topic 7 - women",
  "Decision maker for topic 7 - both",
  "Decision maker for topic 8",
  "Decision maker for topic 8 - men",
  "Decision maker for topic 8 - women",
  "Decision maker for topic 8 - both",
  "Decision maker for topic 9",
  "Decision maker for topic 9 - men",
  "Decision maker for topic 9 - women",
  "Decision maker for topic 9 - both",
  "Decision maker for topic 10",
  "Decision maker for topic 10 - men",
  "Decision maker for topic 10- - women",
  "Decision maker for topic 10- both",
  "Amount of freedom of choice",
  "Amount of freedom of choice - none",
  "Amount of freedom of choice - little",
  "Amount of freedom of choice - some",
  "Amount of freedom of choice - lots",
  "Amount of freedom of choice - at least some",
  "Decide own destiny",
  "Decide own destiny - no",
  "Decide own destiny - little",
  "Decide own destiny - enough",
  "Decide own destiny - a lot",
  "Decide own destiny - at least enough",
  "Make decisions freely",
  "Make decisions freely - never",
  "Make decisions freely - sometimes",
  "Make decisions freely - almost always",
  "Make decisions freely - always",
  "Make decisions freely - at least almost always",
  "Decision to participate in survey",
  "Decision to participate in survey - freely",
  "Decision to participate in survey - freely with consent",
  "Decision to participate in survey - husband consent",
  "Decision to participate in survey - someone's consent",
  "Decision to participate in survey - at least freely with consent"
  )

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Child's play

```r
################################################################################
#
#'
#' Recode child play indicators
#'
#
################################################################################

## Recode responses to a question in the child play indicator set --------------

play_recode_response <- function(x, na_values) {
  ifelse(
    x %in% na_values, NA,
    ifelse(x == 2, 0, 1)
  )
}

## Recode responses to multiple questions in the child play indicator set ------

play_recode_responses <- function(vars, .data, na_values) {
  x <- .data[vars]
  
  apply(
    X = x,
    MARGIN = 2,
    FUN = play_recode_response,
    na_values = c(8, 9),
    simplify = TRUE
  ) |>
    data.frame() |>
    (\(x) { names(x) <- vars; x } )()
}

## Overall recode functions

play_recode <- function(vars, .data, na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- play_recode_responses(
    vars = vars,
    .data = .data,
    na_values = na_values
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions perform recoding of responses for each of the child play indicators. The final function provides overall recoding and concatenates the various child play indicators with the core variables.

To get the final recoded child's play dataset, the following call is performed:

```{r play_function, echo = TRUE, eval = FALSE}
## Play
play_recoded_data = play_recode(
  vars = paste0("play", c(paste0(1, letters[1:7]), 2, paste0(3, letters[1:6]))),
  .data = raw_data_clean,
  na_values = c(8, 9)
)
```

which produces a data.frame with the core variables and the following recoded child's play indicator values:

```{r play_indicators}
indicators <- c(
  paste0("play1", letters[1:7]), "play2", paste0("play3", letters[1:6])
)

desc <- c(
  "Play - sang songs",
  "Play - take a walk",
  "Play - play a game",
  "Play - read a book",
  "Play - told stories",
  "Play - name things",
  "Play - draw things",
  "Have a bag or box for child's things?",
  "Play - when giving a bath",
  "Play - when feeding",
  "Play - when changing clothes",
  "Play - while working at home",
  "Play - while working in the field",
  "Play - during free time"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
``` 

### Income and occupation

```r
################################################################################
#
#' 
#' Process and recode income and occupation data/indicators
#'
#' Relevant variables:
#'
#'   ig1 - What is the main source of income for the family in this household?
#'     integer variables for the following categorical values:
#'     
#'     1=Sale of agricultural products and/or animals; 
#'     2=Self-employed (commercial, service); 
#'     3=Assitncia alimentar/ajuda/ganho ganho/biscate; 
#'     4=Fishing; 
#'     5=Salary, pension, remittance; 
#'     6=Other; 
#'     88=Don't know; 
#'     99=No response 
#'
#'  q08 - Adding the income of all the members of the household, including 
#'    remittances from people who are abroad, receipts, or salary of all adults 
#'    and children in the household who work, which of the following categories 
#'    is the closest to the monthly income of the family in this household?	
#'    integer variables for the following categorical values:
#'
#'    1=No income/or remittances not declared in money; 
#'    2=Less than 60-150 Mts per month; 
#'    3=From Mts 150.01 to Mts 500.00 per month; 
#'    4=From Mts 500.01 to Mts 1500.00 per month; 
#'    5=From Mts 1500.01 to Mts 3500.00 per month; 
#'    6=From Mts 3500.01 to Mts 5500.00 per month; 
#'    7=From Mts 5500.01 to Mts 7500.00 per month; 
#'    8=From Mts 7500.01 to Mts 9500.00 per month; 
#'    9=More than Mts 9500.00 per month; 
#'    88=Don't know; 
#'    99=No response
#'
#'  igs1 - What is your primary occupation? integer variables for the following
#'    categorical values:
#'
#'    1=Homemaker; 
#'    2=Your land; 
#'    3=Fishing; 
#'    4=Wage labor; 
#'    5=Business; 
#'    6=Other; 
#'    88=Don't know; 
#'    99=No response
#'
#'  igs2	What is the primary occupation of your husband/partner? integer
#'    variable for the following categorical values:
#'  
#'    1=None; 
#'    2=Your land; 
#'    3=Fishing; 
#'    4=Wage labor; 
#'    5=Business; 
#'    6=Other; 
#'    7=I do not have a partner/husband; 
#'    88=Don't know; 
#'    99=No response
#'    
#
################################################################################

## Recode responses to 

work_recode_response <- function(x, na_values, fill, na_rm = FALSE, 
                                 prefix, label = NULL) {
  x <- ifelse(x %in% na_values, NA, x)
  
  y <- spread_vector_to_columns(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
  
  if (!is.null(label)) {
    names(y) <- paste0(prefix, "_", label)
  }
  
  work_df <- data.frame(x, y) |>
    (\(x) { names(x)[1] <- prefix; x } )()
  
  work_df
}

work_recode_responses <- function(vars, .data, na_values, fill, na_rm = FALSE, 
                                  prefix, label = NULL) {
  x <- .data[vars]
  x <- apply(X = x, MARGIN = 2, list) |>
    unlist(recursive = FALSE)
  
  Map(
    f = work_recode_response,
    x = x,
    na_values = na_values,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix,
    label = label
  ) |>
    dplyr::bind_cols()
}


work_recode <- function(vars, .data, na_values, fill, na_rm = FALSE, 
                        prefix, label = NULL) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- work_recode_responses(
    vars = vars,
    .data = .data,
    na_values = na_values,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix,
    label = label
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first 2 functions recodes the variables on income source, income amount, occupation and partner's occupation into unique columns. The final function provides overall recoding and concatenates the various income and occupation indicators with the core variables.

To get the final recoded income and occupation dataset, the following call is performed:

```{r work_function, echo = TRUE, eval = FALSE}
## Income and occupation
work_recoded_data = work_recode(
  vars = c("ig1", "q08", "igs1", "igs2"),
  .data = raw_data_clean,
  na_values = list(
    c(88, 99), c(88, 99), 
    c(88, 99), c(7, 88, 99)
  ),
  fill = list(1:6, 1:9, 1:6, 1:6),
  na_rm = rep(list(FALSE), length(vars)),
  prefix = list(
    "income_source", "income_amount", 
    "occupation_carer", "occupation_partner"
  ),
  label = rep(list(NULL), length(vars))
)
```

which produces a data.frame with the core variables and the following recoded income and occupation indicator values:

```{r work_indicators}
indicators <- c(
  paste0("income_source", c("", paste0("_", 1:6))),
  paste0("income_amount", c("", paste0("_", 1:9))),
  paste0("occupation_carer", c("", paste0("_", 1:6))),
  paste0("occupation_partner", c("", paste0("_", 1:6)))
)

desc <- c(
  "Income source",
  "Income source - Sale of agricultural products and/or animals",
  "Income source - Self-employed (commercial, service)",
  "Income source - Assitncia alimentar/ajuda/ganho ganho/biscate",
  "Income source - Fishing",
  "Income source - Salary, pension, remittance",
  "Income source - Other",
  "Income amount",
  "Income amount - No income/or remittances not declared in money",
  "Income amount - Less than 60-150 Mts per month",
  "Income amount - From Mts 150.01 to Mts 500.00 per month",
  "Income amount - From Mts 500.01 to Mts 1500.00 per month",
  "Income amount - From Mts 1500.01 to Mts 3500.00 per month",
  "Income amount - From Mts 3500.01 to Mts 5500.00 per month",
  "Income amount - From Mts 5500.01 to Mts 7500.00 per month",
  "Income amount - From Mts 7500.01 to Mts 9500.00 per month",
  "Income amount - More than Mts 9500.00 per month",
  "Occupation of carer",
  "Occupation of carer - Homemaker",
  "Occupation of carer - Your land",
  "Occupation of carer - Fishing",
  "Occupation of carer - Wage labor",
  "Occupation of carer - Business",
  "Occupation of carer - Other",
  "Occupation of partner",
  "Occupation of partner - None",
  "Occupation of partner - Your land",
  "Occupation of partner - Fishing",
  "Occupation of partner - Wage labor",
  "Occupation of partner - Business",
  "Occupation of partner - Other"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Time-to-travel

```r
################################################################################
#
#'
#' Recode travel indicators/data
#'
#
################################################################################

## Recode others responses to mode of transportation ---------------------------

travel_recode_mode_other <- function(x, y) {
  ## Recode other modes of travel
  x[y %in% c("Barco", "Canoa")]                              <- 7
  x[y %in% c("Carro chapa")]                                 <- 8
  x[y %in% c("Chate")]                                       <- 9
  x[y %in% c("Comboio")]                                     <- 10
  x[stringr::str_detect(y, pattern = "Mota|Moto|mota|moto")] <- 11
  
  x
}

## Recode mode of transportation for specific travel purpose -------------------

travel_recode_mode <- function(x, na_values, fill, na_rm = FALSE, 
                               prefix, label = NULL) {
  x <- ifelse(x %in% na_values, NA, x)
  
  y <- spread_vector_to_columns(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
  
  if (!is.null(label)) {
    names(y) <- paste0(prefix, "_", label)
  }
  
  travel_df <- data.frame(x, y) |>
    (\(x) { names(x)[1] <- prefix; x } )()
  
  travel_df
}

## Recode mode of transportation for multiple travel purposes ------------------

travel_recode_modes <- function(vars, .data, na_values, fill, na_rm = FALSE, 
                                prefix, label = NULL) {
  x <- .data[vars]
  x <- apply(X = x, MARGIN = 2, list) |>
    unlist(recursive = FALSE)
  
  Map(
    f = travel_recode_mode,
    x = x,
    na_values = na_values,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix,
    label = label
  ) |>
    dplyr::bind_cols()
}

## Recode time to travel for specific travel purpose ---------------------------

travel_recode_time <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}

## Recode time to travel for multiple travel purposes --------------------------

travel_recode_times <- function(vars, .data, na_values) {
  x <- .data[vars]
  
  apply(
    X = x,
    MARGIN = 2,
    FUN = travel_recode_time,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame() |>
    (\(x) 
      {
        names(x) <- paste0(
          "travel_times_", 
          c("health_facility", "local_markets", "water_sources")
        )
        x
      }
     )()
}

## Overall travel recode function ----------------------------------------------

travel_recode <- function(.data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  travel_modes <- travel_recode_modes(
    vars = c("gi1", "gi2m", "gi3m", "wt1m"),
    .data = .data,
    na_values = rep(list(c(88, 99)), length(vars)),
    fill = list(1:11, 1:5, 1:5, 1:5),
    na_rm = rep(list(FALSE), length(vars)),
    prefix = paste0(
      "travel_modes_", 
      c("town", "health_facility", "local_markets", "water_sources")
    ),
    label = rep(list(NULL), length(vars))
  )
  
  travel_times <- travel_recode_times(
    vars = c("gi2t", "gi3t", "wt1t"),
    .data = .data,
    na_values = c(88, 99, 888, 999)
  )
  
  data.frame(
    core_vars, travel_modes, travel_times
  )
}
```
The first 2 functions recodes the mode of transport used across the various travel purposes asked of respondent. The next 2 functions recode the time it takes to travel for the various travel purposes asked of respondent. The final function provides overall recoding and concatenates the various travel indicators with the core variables.

To get the final recoded travel dataset, the following call is performed:

```{r travel_function, echo = TRUE, eval = FALSE}
## Time-to-travel
travel_recode_data <- travel_recode(raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded travel indicator values:

```{r travel_indicators}
indicators <- c(
  paste0("travel_modes_town", c("", paste0("_", 1:11))),
  paste0("travel_modes_health_facility", c("", paste0("_", 1:5))),
  paste0("travel_modes_local_markets", c("", paste0("_", 1:5))),
  paste0("travel_modes_water_sources", c("", paste0("_", 1:5))),
  paste0("travel_times_", c("health_facility", "local_markets", "water_sources"))
)

desc <- c(
  "Transport mode to nearest town",
  "Transport mode to nearest town - on foot",
  "Transport mode to nearest town - bicycle",
  "Transport mode to nearest town - bus",
  "Transport mode to nearest town - personal motorised vehicle",
  "Transport mode to nearest town - truck",
  "Transport mode to nearest town - don't travel",
  "Transport mode to nearest town - boat",
  "Transport mode to nearest town - rental car",
  "Transport mode to nearest town - chate",
  "Transport mode to nearest town - train",
  "Transport mode to nearest town - moto or mota hire",
  "Transport mode to health facility",
  "Transport mode to health facility - on foot",
  "Transport mode to health facility - bicycle",
  "Transport mode to health facility - motorcycle",
  "Transport mode to health facility - car",
  "Transport mode to health facility - other",
  "Transport mode to local markets",
  "Transport mode to local markets - on foot",
  "Transport mode to local markets - bicycle",
  "Transport mode to local markets - motorcycle",
  "Transport mode to local markets - car",
  "Transport mode to local markets - other",
  "Transport mode to water sources",
  "Transport mode to water sources - on foot",
  "Transport mode to water sources - bicycle",
  "Transport mode to water sources - motorcycle",
  "Transport mode to water sources - car",
  "Transport mode to water sources - other",
  "Travel time to health facility",
  "Travel time to local markets",
  "Travel time to water sources"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Mosquito net

```r
################################################################################
#
#'
#' Process and recode mosquito nets coverage data/indicators
#' 
#' 
#' Relevant variables:
#'   cdcg13
#' 
#
################################################################################

## Recode responses to the different mosquito net questions --------------------

net_recode_response <- function(x, na_values) {
  ## Net responses with NAs
  net <- ifelse(x %in% na_values, NA, x)
  
  ## Household with any net
  net_any <- ifelse(
    x %in% na_values, NA,
    ifelse(x == 1, 0, 1)
  )
  
  ## Household with adequate nets
  net_adequate <- ifelse(
    x %in% na_values, NA,
    ifelse(x %in% 3:4, 1, 0)
  )
  
  data.frame(
    net, net_any, net_adequate,
    spread_vector_to_columns(
      x = net,
      fill = 1:4,
      na_rm = FALSE,
      prefix = "net"
    ) |>
      (\(x) { names(x) <- paste0("net", 1:4); x } )()
  )
}

## Overall recode function -----------------------------------------------------

net_recode <- function(vars, .data, na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- net_recode_response(
    x = .data[[vars]],
    na_values = na_values
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first function recodes the various mosquito net questions while the last function concatenates the core variables with the recoded responses. 

To get the final recoded mosquito net dataset, the following call is performed:

```{r net_function, echo = TRUE, eval = FALSE}
## Mosquito net
net_recoded_data <- net_recode(
  vars = "cdcg13", 
  .data = raw_data_clean,
  na_values = c(88, 99)
)
```

which produces a data.frame with the core variables and the following recoded mosquito net indicator values:

```{r net_indicators}
indicators <- c(
  "net", "net_any", "net_adequate", paste0("net", 1:4)
)

desc <- c(
  "Net ownership",
  "Net ownership - any",
  "Net ownership - adequate",
  "Net ownership - none",
  "Net ownership - less than the number of beds/sleeping mats",
  "Net ownership - same number as beds/sleeping mats",
  "Net ownership - more than the number of beds/sleeping mats"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Water, sanition and hygiene

#### Water

```r
################################################################################
#
#' 
#' Process and recode water data/indicators
#'
#' Relevant variables:
#'
#'   wt2 - Usually, where do you get your drinking water for the family members 
#'     of the household? integer variables for the following categorial values:
#'     
#'     1=House faucet; 
#'     2=Yard faucet; 
#'     3=Neighbours faucet; 
#'     4=Public faucet; 
#'     5=Water pump; 
#'     6=Well with lid; 
#'     7=Open well; 
#'     8=Protected stream; 
#'     9=Non-protected stream; 
#'     10=Rain; 
#'     11=River/lake/lagoon; 
#'     12=Bottled; 
#'     13=Other; 
#'     88=Don't know; 
#'     99=No response
#'
#'   wt2_other - Specify other source of drinking water; text entry; will need
#'     translation
#'
#'   wt3 - Who usually goes to this source to collect water for the family?
#'     integer variables for the following categorial values:
#'   
#'     1=Adult males; 
#'     2=Adult females; 
#'     3=Young girls; 
#'     4=Young boys; 
#'     5=Other; 
#'     88=Don't know; 
#'     99=No response
#'
#'   wt3a - How long does it take for this person to go collect water, counting 
#'     total time of travel to go, come back, and collect water? integer
#'
#'   wt3b	How many times has this person collected water in the past 7 days?
#'     integer
#'
#'   wt4 - In the last month, has there been a moment in which your household 
#'     did not have sufficient water to drink?
#'     
#'     1=Yes, at least one time; 
#'     2=No, it was always sufficient; 
#'     88=Don't know; 
#'     99=No response
#'
#'   wt4a - What was the principal reason for not being able to access water in 
#'     a sufficient quantity?
#'
#'     1=Water not available at the source; 
#'     2=Water is too expensive; 
#'     3=Source not accessible; 
#'     88=Don't know; 
#'     99=No response
#'
#'   wt5 - Have you ever done anything to the water to make it cleaner to drink?
#'
#'     1=Yes; 
#'     2=No
#'
#'   wt6 - What do you normally do to make your water cleaner to drink?
#'
#'     1=Boil; 
#'     2=Lixivia/chlorine; 
#'     3=Certeza; 
#'     4=Filter with cloth; 
#'     5=Use water filter (ceramic, sand, compost, etc); 
#'     6=Solar disinfection; 
#'     7=Let stand and sit; 
#'     8=Other; 
#'     88=Don't know; 
#'     99=No response   
#'     
#
################################################################################

## Recode responses from a specific question -----------------------------------

water_recode_response <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}

## Recode responses from multiple questions ------------------------------------

water_recode_responses <- function(vars, .data, na_values) {
  x <- .data[vars]
  
  water_df <- apply(
    X = x,
    MARGIN = 2,
    FUN = water_recode_response,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame()
  
  water_df[ , "wt4"] <- ifelse(water_df[ , "wt4"] == 2, 1, 0)
  
  water_df[ , "wt5"] <- ifelse(
    water_df[ , "wt5"] %in% 8:9, NA,
    ifelse(water_df[ , "wt5"] == 2, 0, 1)
  )
  
  water_df
}

################################################################################
#
#'
#' Recode JMP ladder indicators
#' 
#'   surface water
#'   unimproved water source
#'   improved but limited water source
#'   basic water source
#'   sufficient water source
#'
#
################################################################################

water_recode_surface <- function(vars, .data) {
  x <- .data[[vars]]
  
  ifelse(x == 11, 1, 0)
}

water_recode_unimproved <- function(vars, .data) {
  x <- .data[[vars]]
  
  ifelse(x %in% c(7, 9), 1, 0)
}


water_recode_limited <- function(vars, .data) {
  x <- .data[vars]
  
  ifelse(
    x[[vars[1]]] %in% c(1:6, 8, 10, 12) & x[[vars[2]]] > 30, 1, 0
  )
}

water_recode_basic <- function(vars, .data) {
  x <- .data[vars]
  
  ifelse(
    x[[vars[1]]] %in% c(1:6, 8, 10, 12) & x[[vars[2]]] <= 30, 1, 0
  )
}

water_recode_sufficient <- function(vars, .data) {
  x <- .data[vars]
  
  ifelse(
    x[[vars[1]]] %in% 1:2 & x[[vars[2]]] == 1, 1, 0
  )
}

################################################################################
#
#'
#' Recode water collector
#'
#
################################################################################

water_recode_collector <- function(vars, .data,
                                   prefix = "water_collector",
                                   label = c("men", "women", "boys", 
                                             "girls", "others")) {
  x <- .data[[vars]]
  
  data.frame(
    water_collector = x,
    spread_vector_to_columns(
      x = x,
      fill = 1:5,
      na_rm = FALSE,
      prefix = prefix
    ) |>
      (\(x) { names(x) <- paste0(prefix, "_", label); x } )()
  )
}

################################################################################
#
#'
#' Recode water sufficiency
#'
#
################################################################################

water_recode_sufficiency <- function(vars, .data,
                                    prefix = "water_sufficient_reasons") {
  x <- .data[vars]
  
  data.frame(
    water_sufficiency = x[[1]],
    water_sufficient_reasons = x[[2]],
    spread_vector_to_columns(
      x = x[[2]],
      fill = 1:3,
      na_rm = FALSE,
      prefix = prefix
    )
  )
}

################################################################################
#
#'
#' Recode water filter
#'
#
################################################################################

water_recode_filter <- function(vars, .data) {
  x <- .data[[vars]]
  
  ifelse(x %in% c(1:3, 5:6), 1, 0)
}

## Overall recode function -----------------------------------------------------

water_recode <- function(vars, .data, na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  water_df <- water_recode_responses(
    vars = vars, 
    .data = .data, 
    na_values = na_values
  )
  
  recoded_vars <- data.frame(
    water_surface = water_recode_surface(
      vars = "wt2", .data = water_df
    ),
    water_unimproved = water_recode_unimproved(
      vars = "wt2", .data = water_df
    ),
    water_limited = water_recode_limited(
      vars = c("wt2", "wt3a"), .data = water_df
    ),
    water_basic = water_recode_basic(
      vars = c("wt2", "wt3a"), .data = water_df
    ),
    water_sufficient = water_recode_sufficient(
      vars = c("wt2", "wt4"), .data = water_df
    ),
    water_recode_sufficiency(
      vars = c("wt4", "wt4a"), .data = water_df
    ),
    water_recode_collector(
      vars = "wt3", .data = water_df
    ),
    water_collection_time = water_df[["wt3a"]],
    water_filter_use = water_df[["wt5"]],
    water_filter_adequate = water_recode_filter(
      vars = "wt6", .data = water_df
    )
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recodes the various questions in the water indicator set. The next five questions recodes each of the five JMP water ladder indicators based on WHO and UNICEF Joint Monitoring Programme official guidance[^7]. The eighth function recodes the responses to who collects water for the household. The ninth function recodes reasons for water being insufficient. The tenth function recodes the type of water filter used by the household. The final function provides overall recoding and concatenates the various water indicators with the core variables.

To get the final recoded water dataset, the following call is performed:

```{r water_function, echo = TRUE, eval = FALSE}
## Water
water_recoded_data <- water_recode(
  vars = c("wt2", "wt3", "wt3a", "wt3b", "wt4", "wt4a", "wt5", "wt6"),
  .data = raw_data_clean,
  na_values = c(88, 99, 888, 999)
)
```

which produces a data.frame with the core variables and the following recoded water indicator values:

```{r water_indicators}
indicators <- paste0(
  "water_", c("surface", "unimproved", "limited", "basic", "sufficient", "sufficiency"),
  paste0("sufficient_", c("reasons", 1:3)), "collector", 
  paste0("collector_", c("men", "women", "boys", "girls", "others")),
  "collection_time", "filter_use", "filter_adequate"
)

desc <- c(
  "Surface water",
  "Unimproved water source",
  "Improved but limited water source",
  "Basic water source",
  "Sufficient water source",
  "Is water sufficient?",
  "Reasons for not being sufficient - water not available at the source",
  "Reasons for not being sufficient - water is too expensive",
  "Reasons for not being sufficient - source not accessible",
  "Water collector of the household",
  "Water collector - men",
  "Water collector - women",
  "Water collector - boys",
  "Water collector - girls",
  "Water collector - other",
  "Water collection time",
  "Water filter used",
  "Water filter used is adequate"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

#### Sanitation

```r
################################################################################
#
#' 
#' Process and recode sanitation data/indicators
#'
#' Relevant variables:
#'
#'   lusd1 - Does the family in this household use a latrine? integer variables
#'     for the following categorical values:
#'     
#'     1=Yes; 
#'     2=No
#'
#'   lusd2 - Do you share this latrine with other families? integer variables
#'     for the following categorical values:
#'
#'     1=Yes; 
#'     2=No
#'
#'   lusd3 - How many families use this latrine? text entry
#'
#'   lusd4- What type of latrine does this household own? integer variables
#'     for the following categorical values:
#'
#'     1=Toilet with flush; 
#'     2=Toilet without flush; 
#'     3=Improved latrine; 
#'     4=Traditional improved latrine; 
#'     5=Unimproved latrine; 
#'     6=Do not have a latrine/open defecation; 
#'     88=Don't know; 
#'     99=No response
#'
#'   lusd5 - Does this latrine have a lid? integer variables for the following
#'     categorical values:
#'
#'     1=Yes; 
#'     2=No
#'
#'  lusd6 - Where is the latrine located? integer variables for the following
#'    categorical values:
#'
#'    1=In the house; 
#'    2=In the yard; 
#'    3=In another place; 
#'    88=Don't know; 
#'    99=No response
#'
#'   lusd7 - Are there members of this family who defecate in the garden/farm 
#'     where you cultivate your agricultural products to eat? integer variables
#'     for the following categorical values:
#'
#'     1=Yes; 
#'     2=No
#'
#'   lusd8 - Have you seen anyone in your family defecate in the open in the 
#'     last 7 days? integer veriable for the following categorical values:
#'
#'     1=Yes; 
#'     2=No
#'     
#
################################################################################

## Recode responses to specific question ---------------------------------------

san_recode_response <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}

## Recode responses to multiple questions --------------------------------------

san_recode_responses <- function(vars, .data, na_values) {
  x <- .data[vars]
  
  san_df <- apply(
    X = x,
    MARGIN = 2,
    FUN = san_recode_response,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame()
  
  san_df[ , paste0("lusd", c(1:2, 5, 7, 8))] <- ifelse(
    san_df[ , paste0("lusd", c(1:2, 5, 7, 8))] == 2, 0, 1
  )
  
  san_df
}

################################################################################
#
#'
#' Sanitation ladder
#' 
#'   Open defecation
#'   Unimproved sanitation facilities
#'   Improved but limited sanitation facilities
#'   Basic sanitation facilities
#' 
#
################################################################################

san_recode_open <- function(vars, .data) {
  x <- .data[vars]
  
  ifelse(x[[vars[1]]] == 0 | is.na(x[[vars[2]]]), 1, 0)
}

san_recode_unimproved <- function(vars, .data) {
  x <- .data[[vars]]
  
  ifelse(x == 5, 1, 0)
}

san_recode_limited <- function(vars, .data) {
  x <- .data[vars]
  
  ifelse(x[[vars[1]]] != 5 & x[[vars[2]]] == 1, 1, 0)
}

san_recode_basic <- function(vars, .data) {
  x <- .data[vars]
  
  ifelse(x[[vars[1]]] == 5 & x[[vars[2]]] != 1, 1, 0)
}


################################################################################
#
#'
#' Overall recode function
#'
#
################################################################################

san_recode <- function(vars, .data, na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  san_df <- san_recode_responses(
    vars = vars, 
    .data = .data, 
    na_values = na_values
  )
  
  recoded_vars <- data.frame(
    san_open = san_recode_open(vars = c("lusd1", "lusd4"), .data = san_df),
    san_unimproved = san_recode_unimproved(vars = "lusd4", .data = san_df),
    san_limited = san_recode_limited(vars = c("lusd2", "lusd4"), .data = san_df),
    san_basic = san_recode_basic(vars = c("lusd2", "lusd4"), .data = san_df),
    san_open_garden = san_df[["lusd7"]],
    san_open_past = san_df[["lusd8"]]
  )
  
  data.frame(core_vars, recoded_vars)
}
```
The first two functions recodes the various questions in the sanitation indicator set. The next four functions recodes each of the four JMP water ladder indicators based on WHO and UNICEF Joint Monitoring Programme official guidance[^7]. The final function provides overall recoding and concatenates the various sanitation indicators with the core variables.

To get the final recoded sanitation dataset, the following call is performed:

```{r san_function, echo = TRUE, eval = FALSE}
## Sanitation
san_recoded_data <- san_recode(
  vars = paste0("lusd", 1:8),
  .data = raw_data_clean,
  na_values = c(8, 9, 88, 99, 888, 999)
)
```

which produces a data.frame with the core variables and the following recoded sanitation indicator values:

```{r sanitation_indicators}
indicators <- paste0(
  "san_", c("open", "unimproved", "limited", "basic", "open_garden", "open_past")
)

desc <- c(
  "Open defecation",
  "Unimproved sanitation facility",
  "Improved but limited sanitation facility",
  "Basic sanitation facility",
  "Has someone in household defecated in the open in the garden where food is grown?",
  "Has someone in household defecated in the open in the past?"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

#### Hygiene

```r
################################################################################
#
#'
#' Recode hygiene indicators/data
#' 
#' lusd9, lusd10, lusd11
#' caha1, caha2, caha2_other, caha3
#' 
#'
#
################################################################################

## Recode responses to specific questions --------------------------------------

hygiene_recode_response <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}

## Recode responses to multiple questions --------------------------------------

hygiene_recode_responses <- function(vars, .data, na_values) {
  x <- .data[vars]
  
  apply(
    X = x,
    MARGIN = 2,
    FUN = hygiene_recode_response,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame() |>
    (\(x) { names(x) <- vars; x } )()
}

## Recode response to select multiple events of handwashing --------------------

hygiene_recode_events <- function(vars, .data, fill, na_rm = FALSE, prefix) {
  x <- .data[[vars]]
  
  split_select_multiples(
    x = x, 
    fill = fill, 
    na_rm = na_rm, 
    prefix = prefix
  )
}

## Overall recode function -----------------------------------------------------

hygiene_recode <- function(vars, .data, na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  hygiene_df <- hygiene_recode_responses(
    vars = vars,
    .data = .data,
    na_values = na_values
  )
  
  recoded_vars <- data.frame(
    hygiene_wash_recent = ifelse(hygiene_df[[vars[1]]] == 2, 0, 1),
    hygiene_recode_events(
      vars = vars[2],
      .data = hygiene_df,
      fill = 1:6,
      na_rm = FALSE,
      prefix = "handwash_event"
    ),
    hygiene_wash_appropriate = ifelse(hygiene_df[[vars[3]]] == 2, 0, 1),
    hygiene_child_defecation = ifelse(hygiene_df[[vars[4]]] %in% 1:2, 1, 0),
    hygiene_child_disposal = ifelse(hygiene_df[[vars[5]]] %in% c(1, 7), 1, 0),
    hygiene_child_diaper = ifelse(hygiene_df[[vars[6]]] == 1, 1, 0)
  )
  
  data.frame(core_vars, recoded_vars)
} 
```

The first two functions recodes responses to the hygiene questions. The final function provides overall recoding and concatenates the various hygiene indicators with the core variables.

To get the final recoded hygiene dataset, the following call is performed:

```{r hygiene_function, echo = TRUE, eval = FALSE}
## Hygiene
hygiene_recoded_data <- hygiene_recode(
  vars = c(paste0("caha", 1:3), paste0("lusd", 9:11)),
  .data = raw_data_clean,
  na_values = c(8, 9, 88, 99)
)
```

which produces a data.frame with the core variables and the following recoded hygiene indicator values:

```{r hygiene_indicators}
indicators <- paste0(
  "hygiene_", c("wash_recent", paste0("event_", 1:6), "wash_appropriate", "child_defecation", "child_disposal", "child_diaper")
)

desc <- c(
  "Washed hands within the last day",
  "Handwashing event - after using latrine/defecation",
  "Handwashing event - after cleaning up faeces of children",
  "Handwashing event - before preparing food",
  "Handwashing event - before giving food to children",
  "Handwashing event - before eating",
  "Handwashing event - other",
  "Handwashing with soap or ash",
  "Appropriate location for child defecation",
  "Appropriate disposal of child's faeces",
  "Appropriate cleaning/washing of child's soiled diapers"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Child development

```r
################################################################################
#
#'
#' Recode child development indicators
#' 
#
################################################################################

## Recode responses to individual development indicator questions --------------

dev_recode_var <- function(x, na_values) {
  ifelse(
    x %in% na_values, NA,
    ifelse(
      x == 2, 0, 1
    )
  )
}

## Recode responses to multiple development indicator questions ----------------

dev_recode_vars <- function(vars, .data, na_values) {
  vars <- .data[vars]
  
  apply(
    X = vars,
    MARGIN = 2,
    FUN = dev_recode_var,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame() |>
    (\(x) { names(x) <- c("see", "hear"); x })()
}

## Overall recode function -----------------------------------------------------

dev_recode <- function(vars, .data, na_values = c(88, 99)) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- dev_recode_vars(
    vars = vars,
    .data = .data,
    na_values = na_values
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recodes responses to the different child development indicators. The final function provides overall recoding and concatenates the various child development indicators with the core variables.

To get the final recoded child development dataset, the following call is performed:

```{r dev_function, echo = TRUE, eval = FALSE}
## Development milestones
dev_recoded_data <- dev_recode(
  vars = c("des1", "des2"),
  .data = raw_data_clean,
  na_values = c(88, 99)
)
```

which produces a data.frame with the core variables and the following recoded child development indicator values:

```{r dev_indicators}
indicators <- c("see", "hear")

desc <- c(
  "When can a child see?",
  "When can a child hear?"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Pica

```r
################################################################################
#
#'
#' Recode pica
#'
#
################################################################################

## Recode responses to specific pica questions ---------------------------------

pica_recode_var <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}

## Recode responses to all pica questions --------------------------------------

pica_recode_vars <- function(vars, .data, na_values) {
  vars <- .data[vars]
  
  apply(
    X = vars,
    MARGIN = 2,
    FUN = pica_recode_var,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame()
}

## Recode pica diagnosis -------------------------------------------------------

pica_recode_diagnosis <- function(x) {
  ifelse(x >= 3, 1, 0)
}

## Recode pica frequency -------------------------------------------------------

pica_recode_frequency <- function(x) {
  pica_frequencies <- spread_vector_to_columns(
    x = x,
    fill = 1:5,
    na_rm = FALSE,
    prefix = "pica_frequency"
  )
}

## Recode the response to pica knowledge ---------------------------------------

pica_recode_response <- function(x) {
  pica_response <- spread_vector_to_columns(
    x = x,
    fill = 1:5,
    na_rm = FALSE,
    prefix = "pica_response"
  )
}

## Overall recode function -----------------------------------------------------

pica_recode <- function(vars, .data, na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  pica_df <- pica_recode_vars(
    vars = vars,
    .data = .data,
    na_values = na_values
  )
  
  recoded_vars <- data.frame(
    pica_probable = pica_recode_diagnosis(x = pica_df[[vars[1]]]),
    pica_recode_frequency(x = pica_df[[vars[2]]]),
    pica_recode_response(x = pica_df[[vars[2]]]),
    pica_perception = pica_df[[vars[3]]]
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recodes the responses to the different pica indicator questions. The third function recodes responses for a potential pica diagnosis. The fourth question recodes responses to knowledge about pica. The final function provides overall recoding and concatenates the various pica indicators with the core variables.

To get the final recoded pica dataset, the following call is performed:

```{r pica_function, echo = TRUE, eval = FALSE}
pica_recoded_data <- pica_recode(
  vars = c("pica1", "pica2", "pica3"),
  .data = raw_data_clean,
  na_values = c(8, 9, 88, 99)
)
```

which produces a data.frame with the core variables and the following recoded pica indicator values:

```{r pica_indicators}
indicators <- c(
  paste0("pica_", c("probable", paste0("frequency_", 1:5), paste0("response_", 1:5), "perception"))
)

desc <- c(
  "Pica diagnosis - probable",
  "Pica frequency in a week - 0 times",
  "Pica frequency in a week - <1 time per day",
  "Pica frequency in a week - once per day",
  "Pica frequency in a week - two to five times per day",
  "Pica frequency in a week - more than five times per day",
  "Pica response - stop child from putting dirt in their mouth",
  "Pica response - remove dirt from the hands/mouth of the child",
  "Pica response - wash hands of the child with water only",
  "Pica response - wash hands of the child with water and soap/ash",
  "Pica response - do not do anything",
  "Pica perception - is it bad for children to eat dirt?"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Childhood immunisation

### Vitamin A supplementation

```r
################################################################################
#
#'
#' Recode vitamin A indicators
#'
#
################################################################################

## Recode responses to each vitamin A supplementation questions ----------------

vita_recode <- function(.data) {
  vita_at_least_once <- .data[["vas1"]] |>
    (\(x) 
      {
        ifelse(x %in% 4:5, NA,
          ifelse(
            x == 3, 0, 1
          )
        )
      }
    )()
  
  vita2 <- .data[["vas2"]] |>
    (\(x) 
     {
       ifelse(x %in% 4:5, NA,
              ifelse(
                x == 3, 0, 1
              )
       )
    }
    )() |>
    spread_vector_to_columns(
      fill = 0:2,
      na_rm = FALSE, prefix = "vita"
    )
  
  data.frame(vita_at_least_once, vita2)
}

## Recode responses to the deworming indicator question ------------------------

worm_recode <- function(.data) {
  ifelse(
    .data[["vas3"]] == 8, NA,
    ifelse(
      .data[["vas3"]] == 2, 0, 1
    )
  )
}

## Recode both vitamin A and deworming indicators ------------------------------

vas_recode <- function(.data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- data.frame(
    vita_recode(.data),
    deworm = worm_recode(.data)
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first function recodes vitamin A supplementation coverage indicators. The second function recodes the deworming coverage indicators. The final function provides overall recoding and concatenates the vitamin A supplementation and deworming coverage indicators with the core variables.

To get the final recoded vitamin A supplementation and deworming coverage dataset, the following call is performed:

```{r vas_function, echo = TRUE, eval = FALSE}
## VAS coverage
vas_recoded_data <- vas_recode(.data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded vitamin A supplementation and deworming coverage indicator values:

```{r vas_indicators}
indicators <- c(
  "vita_at_least_once", "vita_0", "vita_1", "vita_2", "deworm"
)

desc <- c(
  "Received at least one dose of vitamin A in the past 6 months",
  "Received no vitamin A dose in the last 12 months",
  "Received one vitamain A dose in the last 12 months",
  "Received two vitamin A doses in the last 12 months",
  "Received mebendazole/albendazole in the past 6 months"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Childhood illnesses

#### Fever

```r
################################################################################
#
#'
#' Recode childhood illness - fever
#' 
#' FEVER1	Has **${child_random_name}** been ill with a fever at any time in the 
#' last  two weeks?
#' FEVER2	Did you seek advice or treatment for the fever? 
#' FEVER3	Where did you seek advice or treatment?
#' FEVER4	Was a malaria rapid diagnostic test (RDT) done to 
#'   **${child_random_name}**?
#' FEVER5	Was a laboratory test (blood smear) for diagnosing malaria done for 
#'   **${child_random_name}**?
#' FEVER6	Was the result (RDT/Blood smear) positive for malaria?
#' FEVER6a	What treatment was given to **${child_random_name}**?
#' FEVER7	Did **${child_random_name}** take the antimalarial treatment the same 
#'   day or the day after the onset of the fever?
#' 
#'
#
################################################################################

## Recode responses to specific fever indicator question -----------------------

fever_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to multiple fever indicator questions ----------------------

fever_recode_responses <- function(vars, .data, 
                                   na_values = c(8, 9, 88, 99, "88", "99"), 
                                   binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = fever_recode_response,
    x = as.list(x),
    na_values = rep(list(na_values), length(vars)),
    binary = c(
      rep(list(binary), 2), FALSE, rep(list(binary), 3), FALSE, binary
    ) 
  ) |>
    dplyr::bind_cols()
}

## Recode reported point-of-care for fever -------------------------------------

fever_recode_poc <- function(vars, .data) {
  x <- .data[[vars]]
  
  spread_vector_to_columns(
    x = x,
    fill = 1:6,
    na_rm = FALSE,
    prefix = "fever_poc"
  )
}

## Recode responses to malaria treatment ---------------------------------------

fever_recode_malaria <- function(vars, .data) {
  x <- .data[[vars]]
  
  split_select_multiples(
    x = x,
    fill = 1:7,
    na_rm = FALSE,
    prefix = "fever_malaria"
  )
}

## Overall recode funtion ------------------------------------------------------

fever_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  fever_df <- fever_recode_responses(
    vars = vars, .data = .data
  )
  
  recoded_vars <- data.frame(
    fever_episode = fever_df[[vars[1]]],
    fever_treatment = fever_df[[vars[2]]],
    fever_poc = fever_df[[vars[3]]],
    fever_recode_poc(
      vars = vars[3], .data = fever_df
    ),
    fever_rdt = fever_df[[vars[4]]],
    fever_smear = fever_df[[vars[5]]],
    fever_test = ifelse(
      fever_df[[vars[4]]] == 1 | fever_df[[vars[5]]] == 1, 1, 0
    ),
    fever_test_result = fever_df[[vars[6]]],
    fever_recode_malaria(
      vars = vars[7], .data = fever_df
    ),
    fever_malaria_intake = fever_df[[vars[8]]]
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recodes the responses to each of the fever indicator questions. The third function recodes the point-of-care for fever treatment. The fourth function recodes the malaria treatment used. The final function provides overall recoding and concatenates the fever indicators with the core variables.

To get the final recoded fever dataset, the following call is performed:

```{r fever_function, echo = TRUE, eval = FALSE}
## Treatment-seeking - fever
fever_recoded_data <- fever_recode(
  vars = c(paste0("fever", 1:6), "fever6a", "fever7"),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded fever indicator values:

```{r fever_indicators}
indicators <- c(
  paste0("fever_", c("episode", "treatment", "poc", paste0("poc_", c(1:6)), "rdt", "smear", "test", "result", paste0("malaria_", 1:7), "malaria_intake"))
)

desc <- c(
  "Fever - period prevalence",
  "Fever - seek treatment",
  "Fever point-of-care",
  "Fever point-of-care - health facility",
  "Fever point-of-care - traditional healer",
  "Fever point-of-care - agente polivalente elementar",
  "Fever point-of-care - family member",
  "Fever point-of-care - pharmacy",
  "Fever point-of-care - other",
  "Fever - RDT for malaria administered",
  "Fever - malaria smear test administered",
  "Fever - any malaria test administered",
  "Fever - malaria prevalence (test result)",
  "Fever - malaria treatment - coartem (Al) CP",
  "Fever - malaria treatment - Amodiaquina + Artesanato (ASAQ)",
  "Fever - malaria treatment - fansidar CP",
  "Fever - malaria treatment - quinino CP",
  "Fever - malaria treatment - quinino INJ",
  "Fever - malaria treatment - artesanato",
  "Fever - malaria treatment - Paracetamol Comprimido/Xarope",
  "Fever - malaria treatment intake"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

#### Diarrhoea

```r
################################################################################
#
#'
#' Recode childhood illness - diarrhoea
#' 
#' ORT1	Has **${child_random_name}** had diarrhoea in the last two weeks?
#' ORT1a	On the worst of the days, how many times did **${child_random_name}** 
#'   defecate?
#' ORT1b	How many days did the diarrhoea of **${child_random_name}** last?
#' ORT1c	Does **${child_random_name}** still have diarrhoea?
#' ORT2	Was there blood in the stool?
#' ORT3	Did you seek treatment for the diarrhoea?
#' ORT4	Where did you seek advice or treatment?
#' ORT5a	Did you give **${child_random_name}** a drink made from a packet 
#'   (oral rehydration salts) or oral mixture?
#' ORT5b	Did you give **${child_random_name}** a home-made mixture of water, 
#'   salt, and sugar?
#' ORT5c	Did you give **${child_random_name}** an appropriate drink for 
#'   treating diarrhoea (acquired in a pharmacy)?
#' ORT5d	Was **${child_random_name}** given anything else to treat diarrhoea?
#' ORT5e	What was given to treat diarrhoea?
#' ORT5e_specify	Specify other treatment given
#' ORT6	Did you give **${child_random_name}** the same amount of liquid, more 
#'   or less than usual?
#' ORT7	Did you give **${child_random_name}** the same amount of food, more or 
#'   less than usual?
#'
#
################################################################################

## Recode responses to specific diarrhoea indicator question -------------------

dia_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to multiple diarrhoea indicator questions ------------------

dia_recode_responses <- function(vars, .data, 
                                 na_values = c(list(c(8, 9, 88, 99)),
                                               rep(list(c(88, 99)), 2),
                                               rep(list(c(8, 9, 88, 99)), 8),
                                               list(c("88", "99")),
                                               rep(list(c(8, 9, 88, 99)), 2)),
                                 binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = dia_recode_response,
    x = as.list(x),
    na_values = na_values,
    binary = c(
      binary, rep(list(FALSE), 2), 
      rep(list(binary), 3),
      FALSE,
      rep(list(binary), 4),
      rep(list(FALSE), 3)
    ) 
  ) |>
    dplyr::bind_cols()
}


################################################################################
#
#'
#' Diagnose diarrhoea
#'
#
################################################################################

dia_recode_diagnosis <- function(vars = c(paste0("ort1", c("", letters[1:3])), 
                                          "ort2"), 
                                 .data) {
  x <- .data[vars]
  
  ifelse(
    x[[vars[1]]] == 1 & x[[vars[2]]] > 2 & 
      (x[[vars[3]]] > 2 | x[[vars[4]]] == 1 | x[[vars[5]]] == 1), 1, 0
  )
}

################################################################################
#
#'
#' Diarrhoea treatment point of care
#'
#
################################################################################

dia_recode_poc <- function(vars = "ort4", .data) {
  x <- .data[[vars]]
  
  spread_vector_to_columns(
    x = x,
    fill = 1:6,
    na_rm = FALSE,
    prefix = "diarrhoea_poc"
  )
}

## Recode ORS use --------------------------------------------------------------

dia_recode_ors <- function(vars = paste0("ort5", letters[1:3]), .data) {
  x <- .data[vars]
  
  ifelse(x[[vars[1]]] == 1 | x[[vars[2]]] == 1 | x[[vars[3]]] == 1, 1, 0)
}

################################################################################
#
#'
#' Diarrhoea treatment
#'
#
################################################################################

dia_recode_treatment <- function(vars = "ort5e", .data) {
  x <- .data[[vars]]
  
  split_select_multiples(
    x = x,
    fill = 1:10,
    na_rm = FALSE,
    prefix = "diarrhoea_treatment"
  )
}

################################################################################
#
#'
#' Diarrhoea liquids intake
#'
#
################################################################################

dia_recode_liquids <- function(vars = "ort6", .data,
                               label = c("nothing", "much_less", 
                                         "less", "same", "more")) {
  x <- .data[[vars]]
  
  data.frame(
    diarrhoea_liquids = x,
    diarrhoea_liquids_adequate = ifelse(x == 5, 1, 0),
    spread_vector_to_columns(
      x = x,
      fill = 1:5,
      na_rm = FALSE,
      prefix = "diarrhoea_liquids"
    ) |>
      (\(x) { names(x) <- paste0("diarrhoea_liquids_", label); x } )()
  )
}

################################################################################
#
#'
#' Diarrhoea foods intake
#'
#
################################################################################

dia_recode_foods <- function(vars = "ort7", .data,
                               label = c("nothing", "much_less", 
                                         "less", "same", "more")) {
  x <- .data[[vars]]
  
  data.frame(
    diarrhoea_foods = x,
    diarrhoea_foods_adequate = ifelse(x %in% 4:5, 1, 0),
    spread_vector_to_columns(
      x = x,
      fill = 1:5,
      na_rm = FALSE,
      prefix = "diarrhoea_foods"
    ) |>
      (\(x) { names(x) <- paste0("diarrhoea_foods_", label); x } )()
  )
}

################################################################################
#
#'
#' Recode diarrhoea indicators
#'
#
################################################################################

dia_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  dia_df <- dia_recode_responses(
    vars = vars, .data = .data
  )
  
  recoded_vars <- data.frame(
    diarrhoea_episode = dia_recode_diagnosis(.data = dia_df),
    diarrhoea_treatment = dia_df[[vars[6]]],
    dia_recode_poc(.data = dia_df),
    diarroea_treatment_ors = dia_recode_ors(.data = dia_df),
    dia_recode_treatment(.data = dia_df),
    dia_recode_liquids(.data = dia_df),
    dia_recode_foods(.data = dia_df)
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recodes responses to each of the diarrhoea indicator questions. The third function recodes respective questions to diagnose probable diarrhoea. The fourth function recodes point-of-care for diarrhoea treatment. The fifth function recodes use of oral rehydration solution (ORS). The sixth function recodes treatment modalities employed for diarrhoea. The seventh function recodes liquid intake behaviour during diarrhoea episode. The eighth function recodes food intake behaviour during diarrhoea episode. The final function provides overall recoding and concatenates the diarrhoea indicators with the core variables.

To get the final recoded diarrhoea dataset, the following call is performed:

```{r dia_function, echo = TRUE, eval = FALSE}
## Treatment-seeking - diarrhoea
diarrhoea_recoded_data <- dia_recode(
  vars = c("ort1", paste0("ort1", letters[1:3]), paste0("ort", 2:4), 
           paste0("ort5", letters[1:5]), "ort6", "ort7"),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded diarrhoea indicator values:

```{r dia_indicators}
indicators <- c(
  paste0("diarrhoea_", c("episode", "treatment", paste0("poc_", 1:6), paste0("treatment_", c("ors", 1:10)), c("liquids", paste0("liquids_", c("adequate", "nothing", "much_less", "less", "same", "more")), c("foods", paste0("foods_", c("adequate", "nothing", "much_less", "less", "same", "more"))))))
)

desc <- c(
  "Diarrhoea - period prevalence",
  "Diarrhoea - seek treatment",
  "Diarrhoea point-of-care - health facility",
  "Diarrhoea point-of-care - traditional healer",
  "Diarrhoea point-of-care - agente polivalente elementar",
  "Diarrhoea point-of-care - family member",
  "Diarrhoea point-of-care - pharmacy",
  "Diarrhoea point-of-care - other",
  "Diarrhoea treatment with ORS",
  "Diarrhoea treatment - pills/syrup",
  "Diarrhoea treatment - injections",
  "Diarrhoea treatment - intravenous serum",
  "Diarrhoea treatment - rice water",
  "Diarrhoea treatment - cereal pap",
  "Diarrhoea treatment - tea made of herbs and roots",
  "Diarrhoea treatment - powdered fresh milk",
  "Diarrhoea treatment - tea/fruit juice/coconut milk",
  "Diarrhoea treatment - homemade remedy",
  "Diarrhoea treatment - other",
  "Diarrhoea - liquids intake",
  "Diarrhoea - liquids intake - adequate",
  "Diarrhoea - liquids intake - nothing",
  "Diarrhoea - liquids intake - much less",
  "Diarrhoea - liquids intake - less",
  "Diarrhoea - liquids intake - same",
  "Diarrhoea - liquids intake - more",
  "Diarrhoea - foods intake",
  "Diarrhoea - foods intake - adequate",
  "Diarrhoea - foods intake - nothing",
  "Diarrhoea - foods intake - much less",
  "Diarrhoea - foods intake - less",
  "Diarrhoea - foods intake - same",
  "Diarrhoea - foods intake - more"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

#### Respiratory tract infection

```r
################################################################################
#
#'
#' Recode childhood illness - respiratory tract infection
#' 
#' RI1	Has **${child_random_name}** had a cough or difficulty in breathing in 
#'   the last two weeks?
#' RI2	Did you seek advice or treatment for the breathing problem? 
#' RI3	Where did you seek advice or treatment?
#' CH1	Has **${child_random_name}** had a cough in the last two weeks?
#' CH1a	When **${child_random_name}** had a cough was it accompanied by fever?
#' CH2	When **${child_random_name}** had a cough, did he/she breathe more 
#'   rapidly than usual, with short and rapid breaths?
#' CH3	Did you seek advice or treatment for the cause of the cough?
#' CH4	Where did you seek advice or treatment?
#' CH5	Was **${child_random_name}** given any medicine to treat his/her 
#'   illness?
#' CH5a	What medicine was given to **${child_random_name}**
#' CH5a_other	Specify other medicine given
#'
#
################################################################################

## Recode responses to individual questions ------------------------------------

rti_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
    
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to multiple questions --------------------------------------

rti_recode_responses <- function(vars, .data, 
                                 na_values = c(rep(list(c(8, 9)), 4),
                                               list(c(88, 99)),
                                               list(c(8, 9)),
                                               list(c("88", "99"))),
                                 binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = rti_recode_response,
    x = as.list(x),
    na_values = na_values,
    binary = c(
      rep(list(binary), 3), 
      rep(list(FALSE), 2), binary, FALSE
    ) 
  ) |>
    dplyr::bind_cols()
}

################################################################################
#
#'
#' Diagnose respiratory tract infection
#'
#
################################################################################

rti_recode_diagnosis <- function(vars = c("ch1", "ch1a", "ch2"), 
                                 .data) {
  x <- .data[vars]
  
  ifelse(
    x[[vars[1]]] == 1 & (x[[vars[2]]] == 1 | x[[vars[3]]] == 1), 1, 0
  )
}

## Recode point-of-care --------------------------------------------------------

rti_recode_poc <- function(vars = "ch4", .data) {
  x <- .data[[vars]]
  
  spread_vector_to_columns(
    x = x,
    fill = 1:6,
    na_rm = FALSE,
    prefix = "rti_poc"
  )
}

## Recode treatment ------------------------------------------------------------

rti_recode_treatment <- function(vars = "ch5a", .data) {
  x <- .data[[vars]]
  
  split_select_multiples(
    x = x,
    fill = 1:5,
    na_rm = FALSE,
    prefix = "rti_treatment"
  )
}

## Overall recode function -----------------------------------------------------

rti_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  rti_df <- rti_recode_responses(
    vars = vars, .data = .data
  )
  
  recoded_vars <- data.frame(
    rti_episode = rti_recode_diagnosis(.data = rti_df),
    rti_treatment = rti_df[[vars[4]]],
    rti_recode_poc(.data = rti_df),
    rti_recode_treatment(.data = rti_df)
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recodes the responses for each of the respiratory tract infection questions. The third function diagnoses probable respiratory tract infection. The fourth function recodes point-of-care for respiratory infection. The fifth function recodes treatment given/taken for respiratory tract infection. The final function provides overall recoding and concatenates the respiratory tract infection indicators with the core variables.

To get the final recoded respiratory tract infection dataset, the following call is performed:

```{r rti_function, echo = TRUE, eval = FALSE}
## Treatment-seeking - respiratory tract infections
rti_recoded_data <- rti_recode(
  vars = c("ch1", "ch1a", paste0("ch", 2:5), "ch5a"),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded respiratory tract infection indicator values:

```{r rti_indicators}
indicators <- paste0(
  "rti_", c("episode", "treatment", paste0("poc_", 1:6), paste0("treatment_", 1:5))
)

desc <- c(
  "Respiratory tract infection - period prevalence",
  "Respiratory tract infection - seek treatment",
  "Respiratory tract infection point-of-care - health facility",
  "Respiratory tract infection point-of-care - traditional healer",
  "Respiratory tract infection point-of-care - agente polivalente elementar",
  "Respiratory tract infection point-of-care - family member",
  "Respiratory tract infection point-of-care - pharmacy",
  "Respiratory tract infection point-of-care - other",
  "Respiratory tract infection treatment - antibiotics",
  "Respiratory tract infection treatment - Paracetamol/Panadol/Acetaminophen",
  "Respiratory tract infection treatment - aspirin",
  "Respiratory tract infection treatment - ibuprofen",
  "Respiratory tract infection treatment - other"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Infant and child feeding index

### Food insecurity experience scale

```r
################################################################################
#
#' 
#' Process and recode Food Insecurity Experience Scale (FIES) data/indicators
#'
#' Relevant variables:
#'
#'   fies01 You or others in your household worried about not having enough 
#'     food to eat because of a lack of money or other resources? 1=Yes; 2=No
#'
#'   fies02 Still thinking about the last 30 DAYS, was there a time when you 
#'     or others in your household were unable to eat healthy and nutritious 
#'     food because of a lack of money or other resources? 1=Yes; 2=No
#'
#'   fies03 Was there a time when you or others in your household ate only a 
#'     few kinds of foods because of a lack of money or other resources?
#'    1=Yes; 2=No
#'
#'   fies04 Was there a time when you or others in your household had to skip 
#'     a meal because there was not enough money or other resources to get food?
#'     1=Yes; 2=No
#'
#'   fies05 Still thinking about the last 30 DAYS, was there a time when you or 
#'     others in your household ate less than you thought you should because of 
#'     a lack of money or other resources? 1=Yes; 2=No
#'
#'   fies06 Was there a time when your household ran out of food because of a 
#'     lack of money or other resources? 1=Yes; 2=No
#'
#'   fies07 Was there a time when you or others in your household were hungry 
#'    but did not eat because there was not enough money or other resources for 
#'    food? 1=Yes; 2=No
#'
#'   fies08 Was there a time when you or others in your hou sehold went without 
#'     eating for a whole day because of a lack of money or other resources?
#'     1=Yes; 2=No
#'     
#
################################################################################

## Recode responses to individual FIES question --------------------------------

fies_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to multiple FIES questions ---------------------------------

fies_recode_responses <- function(vars, .data, 
                                  na_values = c(8, 9), 
                                  binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = fies_recode_response,
    x = as.list(x),
    na_values = rep(list(na_values), length(vars)),
    binary = rep(list(binary), length(vars)) 
  ) |>
    dplyr::bind_cols()
}

## Calculate FIES score --------------------------------------------------------

fies_calculate_score <- function(fies_df, na_rm = FALSE, add = TRUE) {
  fies_score <- rowSums(fies_df, na.rm = na_rm)
  
  if (add) {
    fies_score <- data.frame(fies_df, fies_score)
  } else {
    fies_score
  }
  
  fies_score
}

## Overall recode function -----------------------------------------------------

fies_recode <- function(vars = paste0("fies0", 1:8), 
                        .data, 
                        na_values = c(8, 9), 
                        na_rm = TRUE) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- fies_recode_responses(
    vars = vars,
    .data = .data,
    na_values = na_values,
    binary = TRUE
  ) |>
    fies_calculate_score(na_rm = na_rm, add = TRUE)
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recodes responses to the different FIES questions. The third function calculates the overall FIES score. The final function provides overall recoding and concatenates the FIES indicators with the core variables.

To get the final recoded FIES dataset, the following call is performed:

```{r fies_function, echo = TRUE, eval = FALSE}
## FIES
fies_recoded_data <- fies_recode(
  vars = paste0("fies0", 1:8),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded FIES indicator values:

```{r fies_indicators}
indicators <- paste0(
  "fies_0", c(1:8, "score")
)

desc <- c(
  "FIES - not having enough food to eat because of lack of money",
  "FIES - unable to eat healthy and nutritious food because of lack of money",
  "FIES - ate only a few kinds of foods because of lack of money",
  "FIES - skip a meal because of lack of money",
  "FIES - ate less than you should because of lack of money",
  "FIES - ran out of food because of lack of money",
  "FIES - hungry but did not eat because of lack of money",
  "FIES - went without eating for a whole day because of lack of money",
  "FIES score"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Food stocks

```r
################################################################################
#
#'
#' Recode food stocks indicators/data
#'
#
################################################################################

## Recode responses to a food stock indicator question -------------------------

stock_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to specific food stock indicator questions -----------------

stock_recode_responses <- function(vars, .data, 
                                   na_values = c(5, 6, 8, 9), 
                                   binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = stock_recode_response,
    x = as.list(x),
    na_values = rep(list(na_values), length(vars)),
    binary = as.list(rep(c(binary, FALSE), length(vars) / 2)) 
  ) |>
    dplyr::bind_cols()
}

## Recode responses to amounts of stock for specific food item -----------------

stock_recode_amount <- function(vars, .data, prefix) {
  x <- .data[[vars[2]]]
  
  x <- ifelse(.data[[vars[1]]] == 0, 0, x)
  
  reserve_df <- spread_vector_to_columns(
    x = x,
    fill = 0:4,
    na_rm = FALSE,
    prefix = prefix
  )
  
  data.frame(x, reserve_df) |>
    (\(x) { names(x)[1] <- paste0(prefix, "_reserve"); x })()
}

## Recode responses to amounts of stock for multiple food items ----------------

stock_recode_amounts <- function(vars, .data, 
                                 prefix = c("corn", "rice", "millet", 
                                            "sorghum", "cassava", "sweet_potato", 
                                            "legumes")) {
  Map(
    f = stock_recode_amount,
    vars = c(list(vars[1:2]), list(vars[3:4]), list(vars[5:6]), 
             list(vars[7:8]), list(vars[9:10]), list(vars[11:12]), 
             list(vars[13:14])),
    .data = rep(list(.data), length(prefix)),
    prefix = as.list(prefix)
  ) |>
    dplyr::bind_cols()
}

## Overall recode function -----------------------------------------------------

stock_recode <- function(vars, .data, 
                         na_values = c(5, 6, 8, 9), 
                         binary = TRUE,
                         prefix = c("corn", "rice", "millet", 
                                    "sorghum", "cassava", "sweet_potato", 
                                    "legumes")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  stock_df <- stock_recode_responses(
    vars = vars,
    .data = .data
  )
  
  recoded_vars <- stock_recode_amounts(
    vars = vars,
    .data = stock_df
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recode responses to questions on whether household has stocks of a set of foods. The next two functions recode responses to questions on the amount of stocks of a set of foods the household keeps. The final function provides overall recoding and concatenates the food stocks indicators with the core variables.

To get the final recoded food stocks dataset, the following call is performed:

```{r stock_function, echo = TRUE, eval = FALSE}
## Food stocks
stock_recoded_data <- stock_recode(
  vars = c("reserve1", "reserve1a", "reserve2", "reserve2a", 
           "reserve3", "reserve3a", "reserve4", "reserve4a", 
           "reserve5", "reserve5a", "reserve6", "reserve6a", 
           "reserve7", "reserve7a"),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded food stocks indicator values:

```{r stock_indicators}
indicators <- c(
  paste0("corn_", c("reserve", 0:4)),
  paste0("rice_", c("reserve", 0:4)),
  paste0("millet_", c("reserve", 0:4)),
  paste0("sorghum_", c("reserve", 0:4)),
  paste0("cassava_", c("reserve", 0:4)),
  paste0("sweet_potato_", c("reserve", 0:4)),
  paste0("legumes_", c("reserve", 0:4))
)

desc <- c(
  "Corn stocked",
  "Corn stock amount - no stock",
  "Corn stock amount - less than a month",
  "Corn stock amount - 1-3 months",
  "Corn stock amount - 4-6 months",
  "Corn stock amount - more than 6 months",
  "Rice stocked",
  "Rice stock amount - no stock",
  "Rice stock amount - less than a month",
  "Rice stock amount - 1-3 months",
  "Rice stock amount - 4-6 months",
  "Rice stock amount - more than 6 months",
  "Millet stocked",
  "Millet stock amount - no stock",
  "Millet stock amount - less than a month",
  "Millet stock amount - 1-3 months",
  "Millet stock amount - 4-6 months",
  "Millet stock amount - more than 6 months",
  "Sorghum stocked",
  "Sorghum stock amount - no stock",
  "Sorghum stock amount - less than a month",
  "Sorghum stock amount - 1-3 months",
  "Sorghum stock amount - 4-6 months",
  "Sorghum stock amount - more than 6 months",
  "Cassava stocked",
  "Cassava stock amount - no stock",
  "Cassava stock amount - less than a month",
  "Cassava stock amount - 1-3 months",
  "Cassava stock amount - 4-6 months",
  "Cassava stock amount - more than 6 months",
  "Sweet potato stocked",
  "Sweet potato stock amount - no stock",
  "Sweet potato stock amount - less than a month",
  "Sweet potato stock amount - 1-3 months",
  "Sweet potato stock amount - 4-6 months",
  "Sweet potato stock amount - more than 6 months",
  "Legumes stocked",
  "Legumes stock amount - no stock",
  "Legumes stock amount - less than a month",
  "Legumes stock amount - 1-3 months",
  "Legumes stock amount - 4-6 months",
  "Legumes stock amount - more than 6 months"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```


### Pregnancy

```r
################################################################################
#
#'
#' Recode pregnant women indicators
#' 
#' WH1	Are you currently pregnant?
#' WH2	Do you have a prenatal card?
#' WH3	Please, can you hand me the card?
#' WH4	During this pregnancy did you have malaria?
#' WH5	During this pregnancy did you have anaemia?
#' WH6	During this pregnancy did you exclude some type of food from your 
#'   routine diet?
#' WH6a	Specify types of food excluded from routine diet
#' WH7	During this pregnancy did you include some type of food from your 
#'   routine diet?
#' WH7a	Specify types of food included from routine diet
#' WH8	After this pregnancy do you want to have more children?
#' PREG1	Can you please tell me what symptoms are warning signs during 
#'   pregnancy?
#' PREG2	What will you do when labor pain begins?
#' PREG3	Can you tell me what symptoms indicate danger to the health of a 
#' newborn child?
#'
#
################################################################################

## Recode responses to a specific pregnancy indicator question -----------------

preg_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to multiple pregnancy indicator question -------------------

preg_recode_responses <- function(vars, .data, 
                                  na_values = c(rep(list(c(8, 9)), 2), 
                                                list(c(88, 99)), 
                                                rep(list(c(8, 9)), 5), 
                                                rep(list(c(88, 99)), 3)), 
                                  binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = preg_recode_response,
    x = as.list(x),
    na_values = na_values,
    binary = as.list(c(rep(binary, 2), FALSE, rep(binary, 5), rep(FALSE, 3)))
  ) |>
    dplyr::bind_cols()
}

## Recode responses to card retention indicator --------------------------------

preg_recode_card <- function(vars, .data) {
  x <- .data[[vars]]
  
  spread_vector_to_columns(
    x = x,
    fill = 1:3,
    na_rm= FALSE, 
    prefix = "pnc_card"
  )
}

## Recode responses to pregnancy danger signs indicators -----------------------

preg_recode_danger <- function(vars, .data, na_rm = TRUE, prefix = "danger") {
  x <- .data[[vars]]
  
  danger_df <- split_select_multiples(
    x = x,
    fill = 1:10,
    na_rm = na_rm,
    prefix = prefix
  )
  
  danger_all <- rowSums(danger_df, na.rm = FALSE)
  
  danger_prop <- ifelse(danger_all == 10, 1, 0)
  
  data.frame(danger_df, danger_all, danger_prop)
}

## Recode responses to what respondent would do if she goes into labour --------

preg_recode_labor <- function(vars, .data, na_rm = FALSE, prefix = "labor") {
  x <- .data[[vars]]
  
  spread_vector_to_columns(
    x = x,
    fill = 1:6,
    na_rm = na_rm,
    prefix = prefix
  )
}

## Recode responses to danger signs for newborn --------------------------------

preg_recode_newborn <- function(vars, .data, na_rm = TRUE, prefix = "newborn") {
  x <- .data[[vars]]
  
  split_select_multiples(
    x = x,
    fill = 1:8,
    na_rm = na_rm,
    prefix = prefix
  )
}

## Overall recode function -----------------------------------------------------

preg_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  preg_df <- preg_recode_responses(
    vars = vars, .data = .data
  )
  
  recoded_vars <- data.frame(
    preg_card = preg_df[[vars[2]]],
    preg_recode_card(vars = vars[3], .data = preg_df),
    preg_malaria = preg_df[[vars[4]]],
    preg_anaemia = preg_df[[vars[5]]],
    preg_exclude = preg_df[[vars[6]]],
    preg_include = preg_df[[vars[7]]],
    preg_more = preg_df[[vars[8]]],
    preg_recode_danger(vars = vars[9], .data = preg_df),
    preg_recode_labor(vars = vars[10], .data = preg_df),
    preg_recode_newborn(vars = vars[11], .data = preg_df)
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recode responses to each pregnancy indicator questions. The third function recodes whether respondent has a prenatal card. The fourth function recodes responses to pregnancy danger signs indicators. The fifth function recodes responses to what the respondent would do if she goes into labour. The sixth function recodes responses to newborn danger signs. The final function provides overall recoding and concatenates the pregnancy indicators with the core variables.

To get the final recoded pregnancy dataset, the following call is performed:

```{r preg_function, echo = TRUE, eval = FALSE}
## Pregnancy
preg_recoded_data <- preg_recode(
  vars = c("wh1", "wh2", "wh3", "wh4", "wh5", "wh6", "wh7", 
           "wh8", "preg1", "preg2", "preg3"),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded pregnancy indicator values:

```{r preg_indicators}
indicators <- c(
  "preg_card", paste0("pnc_card_", 1:3), "preg_malaria", "preg_anaemia", "preg_exclude",
  "preg_include", "preg_more", paste0("danger_", c(1:10, "all", "prop")), paste0("labor_", 1:6),
  paste0("newborn", 1:8)
)

desc <- c(
  "Pregnancy - prenatal card",
  "Pregnancy - prenatal card - yes",
  "Pregnancy - prenatal card - yes, but did not hand the card over",
  "Pregnancy - prenatal card - no",
  "Pregnancy - had malaria",
  "Pregnancy - had anaemia",
  "Pregnancy - exclude any foods",
  "Pregnancy - include any foods",
  "Pregnancy - eat more foods",
  "Pregnancy - danger sign - bleeding or vaginal fluid",
  "Pregnancy - danger sign - severe headache",
  "Pregnancy - danger sign - blurry vision",
  "Pregnancy - danger sign - swollen hands and feet",
  "Pregnancy - danger sign - convulsions",
  "Pregnancy - danger sign - fever",
  "Pregnancy - danger sign - intense abdominal pain",
  "Pregnancy - danger sign - loss of consciousness",
  "Pregnancy - danger sign - fatigue",
  "Pregnancy - danger sign - accelerated/diminished fetal movement",
  "Pregnancy - danger sign - reported all danger signs",
  "Pregnancy - danger sign - reported 8 of 10 danger signs",
  "Pregnancy - labor - go to the closest hospital",
  "Pregnancy - labor - aks a nearby relative/family member/neighbour to come help",
  "Pregnancy - labor - call a traditional birth attendant",
  "Pregnancy - labor - stay alone with your husband/partner",
  "Pregnancy - labor - stay all alone",
  "Pregnancy - labor - other",
  "Pregnancy - newborn danger sign - difficulty breathing",
  "Pregnancy - newborn danger sign - jaundice",
  "Pregnancy - newborn danger sign - poor feeding",
  "Pregnancy - newborn danger sign - fever",
  "Pregnancy - newborn danger sign - cold body",
  "Pregnancy - newborn danger sign - convulsions",
  "Pregnancy - newborn danger sign - vomiting",
  "Pregnancy - newborn danger sign - lack of stooling"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Pre- and post-natal care

```r
################################################################################
#
#'
#' Recode pre- and post-natal care
#' 
#' SPC1	Where was the delivery of your last child completed?
#' SPC2	How many pre-natal care visits did you complete during your last 
#'   pregnancy or your current pregnancy?
#' SPC2a	Were you treated well by the staff at the health facility during 
#'   your pre-natal visits?
#' SPC2b	Were you treated well by the staff at the health facility when you 
#'   delivered your last child?
#' SPC3	Who assisted the delivery of your last child?
#' SPC4	Would you return to the health facility to deliver your next child?
#' SPC5	Did you have any difficulty or problems reaching the facility?
#' SPC5a	Which difficulties?
#' SPC6	How long after the birth of your last child did you go to the facility 
#'   for a check-up of the baby?
#' SPC6a	How many hours after birth of your last child did you go to the 
#'   facility for a check-up of the baby?
#' SPC6b	How many days after birth of your last child did you go to the 
#'   facility for a check-up of the baby?
#' SPC7	How long after the birth of your last child did you go to the facility 
#'   for a check-up of yourself?
#' SPC7a	How many hours after birth of your last child did you go to the 
#'   facility for a check-up yourself?
#' SPC7b	How many days after birth of your last child did you go to the 
#'   facility for a check-up of yourself?
#' THER1	After the birth of your last child, did he/she receive protection 
#'   against the cold (cleaning/drying, direct skin to skin contact with the 
#'   mother, covering the body and head of the child)?
#'
#
################################################################################

## Recode responses to an individual natal care question -----------------------

nc_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to multiple natal care questions ---------------------------

nc_recode_responses <- function(vars, .data,
                                na_values = c(rep(list(c(88, 99)), 2),
                                              rep(list(c(8, 9)), 2),
                                              list(c(88, 99)),
                                              rep(list(c(8, 9)), 2),
                                              rep(list(c(88, 99)), 7),
                                              list(c(8, 9))),
                                binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = nc_recode_response,
    x = as.list(x),
    na_values = na_values,
    binary = as.list(c(rep(FALSE, 2), rep(binary, 2), FALSE, 
                     rep(binary, 2), rep(FALSE, 7), binary))
  ) |>
    dplyr::bind_cols()
}

## Recode responses for where most recent birth happened -----------------------

nc_recode_location <- function(vars, .data, 
                               fill = 1:5, na_rm = FALSE, 
                               prefix = "delivery_location") {
  x <- .data[[vars]]
  
  data.frame(
    delivery_location = x,
    spread_vector_to_columns(
      x = x,
      fill = fill,
      na_rm = na_rm,
      prefix = prefix
    )
  )
}

## Recode antenatal care coverage ----------------------------------------------

nc_recode_anc <- function(vars, .data) {
  x <- .data[[vars]]
  
  #anc_one <- ifelse(x[[vars[1]]] != 1 & x[[vars[2]]] %in% c(1:3, 5:6), 1, 0)
  #anc_four <- ifelse(x[[vars[1]]] %in% 4:5, 1, 0)
  anc_four <- ifelse(x %in% 4:5, 1, 0)
  
  #data.frame(anc_one, anc_four)
  anc_four
}

## Recode responses to who assisted in delivery of child -----------------------

nc_recode_assist <- function(vars, .data, 
                             fill = 1:9, na_rm = FALSE, 
                             prefix = "delivery_assist") {
  x <- .data[[vars]]
  
  data.frame(
    delivery_assist = x,
    spread_vector_to_columns(
      x = x,
      fill = fill,
      na_rm = na_rm,
      prefix = prefix
    )
  )
}

## Recode responses to difficulties during delivery ----------------------------

nc_recode_difficulties <- function(vars, .data,
                                   fill = 1:6, na_rm = FALSE,
                                   prefix = "delivery_difficulty") {
  x <- .data[[vars]]
  
  data.frame(
    delivery_difficulty = x,
    spread_vector_to_columns(
      x = x,
      fill = fill,
      na_rm = na_rm,
      prefix = prefix
    )
  )
}

## Recode post-natal care indicators -------------------------------------------

nc_recode_pnc <- function(vars, .data, prefix) {
  x <- .data[vars]
  
  days_to_pnc <- ifelse(
    x[[vars[1]]] == 1, 0,
    ifelse(
      x[[vars[1]]] == 2, x[[vars[2]]] / 24, x[[vars[3]]]
    )
  )
  
  pnc_check <- ifelse(
    days_to_pnc == 0, 1,
    ifelse(
      days_to_pnc > 0 & days_to_pnc <= 2, 2,
      ifelse(
        days_to_pnc > 2 & days_to_pnc < 42, 3, 0
      )
    )
  )
  
  data.frame(
    days_to_pnc,
    pnc_check,
    spread_vector_to_columns(
      x = pnc_check,
      fill = 0:3,
      na_rm = FALSE,
      prefix = prefix
    )
  )
}

## Overall recode function -----------------------------------------------------

nc_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  nc_df <- nc_recode_responses(
    vars = vars, .data = .data
  )
  
  recoded_vars <- data.frame(
    nc_recode_location(vars = vars[1], .data = nc_df),
    anc_four = nc_recode_anc(vars = vars[2], .data = nc_df),
    anc_well = nc_df[[vars[3]]],
    delivery_well = nc_df[[vars[4]]],
    nc_recode_assist(vars = vars[5], .data = nc_df),
    delivery_return = nc_df[[vars[6]]],
    nc_recode_difficulties(vars = vars[8], .data = nc_df),
    nc_recode_pnc(vars = vars[9:11], .data = nc_df, prefix = "pnc_mother") |>
      (\(x) { names(x)[1:2] <- paste0("mother_", names(x)[1:2]); x } )(),
    nc_recode_pnc(vars = vars[12:14], .data = nc_df, prefix = "pnc_child") |>
      (\(x) { names(x)[1:2] <- paste0("child_", names(x)[1:2]); x } )(),
    nc_protect = nc_df[[vars[15]]]
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recode responses to the natal care indicator questions. The third function recodes responses to where the birth of the youngest child has occurred. The fourth function recodes antenatal coverage based on official WHO guidance[^8]. The fifth function recodes responses on who assisted in the delivery of the youngest child. The sixth function recodes resopnses on difficulties faced during delivery. The seventh function recodes the post-natal care indicators. The final function provides overall recoding and concatenates the natal care indicators with the core variables.

To get the final recoded natal care dataset, the following call is performed:

```{r nc_function, echo = TRUE, eval = FALSE}
## Pre- and post-natal check
nc_recoded_data <- nc_recode(
  vars = c(paste0("spc", 1:2), paste0("spc2", letters[1:2]),
           paste0("spc", 3:5), "spc5a", "spc6", paste0("spc6", letters[1:2]),
           "spc7", paste0("spc7", letters[1:2]), "ther1"),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded natal care indicator values:

```{r nc_indicators}
indicators <- c(
  paste0("delivery_", c("location", paste0("location_", 1:5))),
  "anc_four", "anc_well", "delivery_well", paste0("delivery_assist_", 1:9),
  "delivery_return", paste0("delivery_", c("difficulty", paste0("difficulty_", 1:6))),
  "mother_days_to_pnc", "mother_pnc_check", paste0("pcn_mother_", 0:3),
  "child_days_to_pnc", "child_pnc_check", paste0("pnc_child_", 0:3), "nc_protect"
)

desc <- c(
  "Delivery location",
  "Delivery location - health facility/hospital",
  "Delivery location - in your own house",
  "Delivery location - house of traditional birth attendant",
  "Delivery location - house of a neighbour/family member",
  "Delivery locaiton - other",
  "At least 4 antenatal care visits with any service provider",
  "Treated well during antenatal care visits",
  "Treated well during delivery",
  "Delivery assisted by doctor",
  "Delivery assisted by nurse",
  "Delivery assisted by midwife",
  "Delivery assisted by other person",
  "Delivery assisted by traditional midwife",
  "Delivery assisted by community health worker",
  "Delivery assisted by relative/friend",
  "Delivery assisted by other",
  "Delivery assisted by nobody",
  "Delivery - return to the same facility",
  "Delivery - difficutlies",
  "Delivery - difficulties - cost",
  "Delivery - difficulties - distance",
  "Delivery - difficulties - stigma",
  "Delivery - difficulties - poor roads",
  "Delivery - difficulties - other",
  "Delivery - difficulties - no",
  "Number of days after delivery mother went for post-natal care",
  "Post-natal check - mother",
  "Post-natal check - mother - immediately",
  "Post-natal check - mother - within 2 days",
  "Post-natal check - mother - within 42 days",
  "Post-natal check - mother - none",
  "Number of days after delivery child was brought for post-natal care",
  "Post-natal check - child",
  "Post-natal check - child - immediately",
  "Post-natal check - child - within 2 days",
  "Post-natal check - child - within 42 days",
  "Post-natal check - child - none",
  "Child protected from the elements after delivery"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Prevention of mother-to-child transmission

```r
################################################################################
#
#'
#' Recode PMTCT
#' 
#' PMTCT1	During your pregnancy with your last child or during your current 
#'   pregnancy, were you offered voluntary counseling and testing (VCT)?
#' PMTCT2	Did you receive the results?
#' PMTCT3	Were you offered medication to lower the chance of your child 
#'   getting HIV?
#'
#
################################################################################

## Recode resposes to a specific PMTCT indicator question ----------------------

pmtct_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to multiple PMTCT indicator questions ----------------------

pmtct_recode_responses <- function(vars, .data,
                                   na_values = c(8, 9),
                                   binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = pmtct_recode_response,
    x = as.list(x),
    na_values = rep(list(na_values), length(vars)),
    binary = rep(list(binary), length(vars))
  ) |>
    dplyr::bind_cols()
}

## Overall recode function -----------------------------------------------------

pmtct_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- pmtct_recode_responses(vars = vars, .data = .data)
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recode the PMTCT indicator questions. The final function provides overall recoding and concatenates the PMTCT indicators with the core variables.

To get the final recoded PMTCT dataset, the following call is performed:

```{r pmtct_function, echo = TRUE, eval = FALSE}
## PMTCT
pmtct_recoded_data <- pmtct_recode(
  vars = paste0("pmtct", 1:3),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded PMTCT indicator values:

```{r pmtct_indicators}
indicators <- c(
  paste0("pmtct", 1:3)
)

desc <- c(
  "Offered VCT during latest pregnancy",
  "Received results",
  "Offered medication to lower risk of transmission to baby"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Mosquito net during pregnancy

```r
################################################################################
#
#'
#' Recode mosquito net during pregnancy
#' 
#' IDK1	During your pregnancy with your last child or during your current 
#'   pregnancy, did you receive a mosquite net?
#' IDK2	During your pregnancy with your last child or during your current 
#'   pregnancy, did you sleep/do you sleep under a mosquito net?
#'
#
################################################################################

## Recode responses to pregnancy net indicator ---------------------------------

pnet_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to pregnancy net indicators --------------------------------

pnet_recode_responses <- function(vars, .data,
                                  na_values = c(8, 9),
                                  binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = pnet_recode_response,
    x = as.list(x),
    na_values = rep(list(na_values), length(vars)),
    binary = rep(list(binary), length(vars))
  ) |>
    dplyr::bind_cols()
}

## Overall recode function -----------------------------------------------------

pnet_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- pnet_recode_responses(vars = vars, .data = .data)
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recode the mosquito net during pregnancy indicator questions. The final function provides overall recoding and concatenates the mosquite net during pregnancy indicators with the core variables.

To get the final recoded mosquito net during pregnancy dataset, the following call is performed:

```{r pnet_function, echo = TRUE, eval = FALSE}
## Pregnancy - mosquito net
pnet_recoded_data <- pnet_recode(
  vars = paste0("idk", 1:2),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded mosquito net during pregnancy indicator values:

```{r pnet_indicators}
indicators <- c(
  "idk1", "idk2"
)

desc <- c(
  "Received mosquito net",
  "Slept under mosquito net"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Family planning

```r
################################################################################
#
#'
#' Recode family planning indicators 
#' 
#' PF1	Have you ever used or tried a method to delay or avoid pregnancy?
#' BS1	Is there an ideal moment to wait after birth before trying to get 
#'   pregnant again?
#' BS1a	What is the ideal period to wait?
#' BS2	What are the benefits of waiting?
#' BS2a	Specify other benefits
#' BS3	Are there benefits to waiting until after age 18 years?
#' BS3a	Specify other benefits
#' BS4	Are there problems that can occur for a woman to be pregnant when she 
#'   has more than four children?
#' BS4a	Specify other problems when a woman has more than four children
#' ABOR1	Is there an ideal moment to wait after a spontaneous abortion before 
#'   trying to get pregnant again?
#' ABOR1a	What is the ideal period to wait?
#'
#
################################################################################

## Recode other responses to benefits of waiting before next pregnancy ---------

fp_recode_bs2a <- function(x, y) {
  ## Recode other planning benefits
  x <- ifelse(
    stringr::str_detect(x, "5| 5") & stringr::str_detect(y, "growth|grow|development"),  
    paste0(stringr::str_remove(x, "5| 5"), " 7"), 
    x
  )
  
  x
}

## Recode other responses to benefits of waiting before first pregnancy --------

fp_recode_bs3a <- function(x, y) {
  ## Recode other planning benefits
  x <- ifelse(
    stringr::str_detect(x, "5| 5") & stringr::str_detect(y, "education|studies|study|professional|Studying"),  
    paste0(stringr::str_remove(x, "5| 5"), " 7"), 
    x
  )
  
  x <- ifelse(
    stringr::str_detect(x, "5| 5") & stringr::str_detect(y, "danger|death|sezarian"),  
    paste0(stringr::str_remove(x, "5| 5"), " 8"), 
    x
  )
  
  x <- ifelse(
    stringr::str_detect(x, "5| 5") & stringr::str_detect(y, "growth|mature|maturity|grow"),  
    paste0(stringr::str_remove(x, "5| 5"), " 9"), 
    x
  )

  x
}

## Recode benefits of waiting before pregnancy after abortion ------------------

fp_recode_bs4a <- function(x, y) {
  ## Recode other planning benefits
  x[stringr::str_detect(y, "mother|health")] <- 7
  x[stringr::str_detect(y, "cesarean")]      <- 8  
  x[stringr::str_detect(y, "depend|Depend")] <- 9
  x
}

## Recode responses for a specific question ------------------------------------

fp_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses for multiple questions -------------------------------------

fp_recode_responses <- function(vars, .data,
                                na_values = c(rep(list(c(8, 9)), 2), 
                                              list(c(8, 9, 78, 88, 99)),
                                              rep(list(c(88, 99)), 3),
                                              list(c(8, 9)),
                                              list(c(88, 99))),
                                binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = fp_recode_response,
    x = as.list(x),
    na_values = na_values,
    binary = as.list(c(rep(binary, 2), rep(FALSE, 4), 
                       binary, FALSE))
  ) |>
    dplyr::bind_cols()
}

## Recode ideal waiting time to get pregnant again (minimum 18 months) ---------

fp_recode_wait_time <- function(vars, .data) {
  x <- .data[[vars]]
  
  data.frame(
    fp_wait_time = x,
    fp_wait_time_appropriate = ifelse(x >= 18, 1, 0)
  )
}

## Recode benefits of waiting for next pregnancy -------------------------------

fp_recode_benefit_next <- function(vars, .data, fill = 1:7, 
                                   na_rm = FALSE, prefix = "benefit_next") {
  x <- .data[[vars]]
  
  split_select_multiples(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
}

## Recode benefits for waiting before first pregnancy --------------------------

fp_recode_benefit_first <- function(vars, .data, fill = 1:9, 
                                    na_rm = FALSE, prefix = "benefit_first") {
  x <- .data[[vars]]
  
  split_select_multiples(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
}

## Recode dangers of multiparity -----------------------------------------------

fp_recode_multiparity <- function(vars, .data, fill = 1:9, 
                                  na_rm = FALSE, 
                                  prefix = "multiparity_danger") {
  x <- .data[[vars]]
  
  spread_vector_to_columns(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
}

## Recode reasons for waiting after spontaneous abortion -----------------------

fp_recode_wait_abort <- function(vars, .data) {
  x <- .data[[vars]]
  
  data.frame(
    fp_wait_abort = x,
    fp_wait_abort_appropriate = ifelse(x >= 6, 1, 0)
  )
}

## Overall recode --------------------------------------------------------------

fp_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  .data[[vars[4]]] <- fp_recode_bs2a(
    x = .data[[vars[4]]], y = .data[["bs2a_en"]]
  )
  
  .data[[vars[5]]] <- fp_recode_bs2a(
    x = .data[[vars[5]]], y = .data[["bs3a_en"]]
  )
  
  .data[[vars[6]]] <- fp_recode_bs2a(
    x = .data[[vars[6]]], y = .data[["bs4a_en"]]
  )
  
  x <- .data[vars]
  
  fp_df <- fp_recode_responses(vars = vars, .data = .data)
  
  recoded_vars <- data.frame(
    fp_use = fp_df[[vars[1]]],
    fp_wait = fp_df[[vars[2]]],
    fp_recode_wait_time(vars = vars[3], .data = fp_df),
    fp_recode_benefit_next(vars = vars[4], .data = fp_df),
    fp_recode_benefit_first(vars = vars[5], .data = fp_df),
    fp_recode_multiparity(vars = vars[6], .data = fp_df),
    fp_wait_abort = fp_df[[vars[7]]],
    fp_recode_wait_abort(vars = vars[8], .data = fp_df)
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first 3 functions recode other responses to question on benefits of waiting before next pregnancy, benefits of waiting before first pregnancy, and dangers of multiparity. Once these have been recoded and added into the main indicator, the fourth and fifth functions processes each question/variable and recodes them appropriately. The sixth function recodes the indicator for ideal waiting time for next pregnancy. The seventh, eighth and ninth function recodes the indicators for benefits of waiting before next pregnancy, benefits of waiting before first pregnancy, and dangers of multiparity. The tenth function recodes the ideal waiting time to wait to get pregnant after spontaneous abortion. The final function provides overall recoding and concatenates the various travel indicators with the core variables.

To get the final recoded family planning dataset, the following call is performed:

```{r fp_function, echo = TRUE, eval = FALSE}
## Family planning
fp_recoded_data = fp_recode(
  vars = c("pf1", "bs1", "bs1a", "bs2", "bs3", "bs4", "abor1", "abor1a"),
  .data = raw_data_clean_translated
)
```

which produces a data.frame with the core variables and the following recoded family planning indicator values:

```{r fp_indicators}
indicators <- c(
  paste0("fp_", c("use", "wait_time", "wait_time_appropriate")),
  paste0("benefit_next_", 1:7),
  paste0("benefit_first_", 1:9),
  paste0("multiparity_danger_", 1:9),
  "fp_wait_abort", "fp_wait_abort_appropriate"
)

desc <- c(
  "Use any family planning method",
  "Knowledge of ideal waiting time before next pregnancy",
  "Knowledge of ideal waiting time before next pregnancy is appropriate",
  "Benefit of waiting before next pregnancy - less risk to the health of the mother",
  "Benefit of waiting before next pregnancy - less risk to the health of the child",
  "Benefit of waiting before next pregnancy - avoid poverty",
  "Benefit of waiting before next pregnancy - more likely that children will be educated",
  "Benefit of waiting before next pregnancy - other",
  "Benefit of waiting before next pregnancy - none",
  "Benefit of waiting before next pregnancy - growth and development of current child",
  "Benefit of waiting until after 18 years of age - less risk to the health of the mother",
  "Benefit of waiting until after 18 years of age - less risk to the health of the child",
  "Benefit of waiting until after 18 years of age - avoid poverty",
  "Benefit of waiting until after 18 years of age - more likely that children will be educated",
  "Benefit of waiting until after 18 years of age - other",
  "Benefit of waiting until after 18 years of age - none",
  "Benefit of waiting until after 18 years of age - best chances of completing education",
  "Benefit of waiting until after 18 years of age - avoid maternal mortality/morbidity",
  "Benefit of waiting until after 18 years of age - give time for woman to grow and mature",
  "Danger of having 4 children - maternal mortality",
  "Danger of having 4 children - child mortality",
  "Danger of having 4 children - poverty",
  "Danger of having 4 children - decreased chances of children getting education",
  "Danger of having 4 children - other",
  "Danger of having 4 children - none",
  "Danger of having 4 children - maternal morbidity",
  "Danger of having 4 children - complicated pregnancies",
  "Danger of having 4 children - it depends",
  "Knowledge of ideal time to get pregnant after a spontaneous abortion",
  "Knowledge of ideal time to get pregnant after a sponetaneous aborition is appropriate"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Other reproductive health indicators

```r
################################################################################
#
#'
#' CHM1	Have you ever given birth to a boy or girl who was born alive but later 
#'   died?
#' CHM2	Have any of your children died before their 5th birthday?
#' FANSIDAR1	During your last pregnancy were you given SP/Fansidar or 
#'   cotrimoxazole liek this one (show tablets) to treat your malaria during 
#'   your prenatal care visits?
#' FANSIDAR2	How many times did you take SP/Fansidar or cotrimoxazole during 
#'   your last pregnancy?
#' FOL1	During your last pregnancy, did you receive iron supplements to take?
#' TT1	During your last pregnancy, were you given an injection in the arm to 
#'   prevent the baby from getting tetanus, that is, convulsions after birth?
#' TT2	During your last pregnancy, how many times did you get this tetanus 
#'   injection?
#'
#'
#
################################################################################

## Recode responses to individual reproductive health questions ----------------

rh_recode_response <- function(x, na_values, binary = TRUE) {
  na_type <- get_na_type(x)
  
  if (binary) {
    ifelse(
      x %in% na_values, na_type,
      ifelse(x == 2, 0, 1)
    )
  } else {
    ifelse(x %in% na_values, na_type, x)
  }
}

## Recode responses to multiple reproductive health questions ------------------

rh_recode_responses <- function(vars, .data,
                                na_values = rep(list(c(8, 9, 88, 99)), 7),
                                binary = TRUE) {
  x <- .data[vars]
  
  Map(
    f = rh_recode_response,
    x = as.list(x),
    na_values = na_values,
    binary = as.list(c(rep(binary, 3), FALSE, 
                       rep(binary, 2), FALSE))
  ) |>
    dplyr::bind_cols()
}

## Recode responses to malaria during pregnancy indicators ---------------------

rh_recode_malaria <- function(vars, .data) {
  x <- .data[vars]
  
  mal_prevalence <- ifelse(x[[vars[1]]] == 1, 1, 0)
  mal_no_treatment <- ifelse(x[[vars[2]]] == 1, 1, 0)
  mal_appropriate_treatment <- ifelse(x[[vars[2]]] == 4, 1, 0)
  
  data.frame(
    mal_prevalence, mal_no_treatment, mal_appropriate_treatment
  )
}

## Recode responses to tetanus toxoid coverage during pregnancy indicators -----

rh_recode_tetanus <- function(vars, .data) {
  x <- .data[vars]
  
  tt_any <- x[[vars[1]]]
  tt_two_more <- ifelse(x[[vars[2]]] != 1, 1, 0)
  
  data.frame(tt_any, tt_two_more)
}

## Overall recode function -----------------------------------------------------

rh_recode <- function(vars, .data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  rh_df <- rh_recode_responses(
    vars = vars, .data = .data
  )
  
  recoded_vars <- data.frame(
    mort1 = rh_df[[vars[1]]],
    mort2 = rh_df[[vars[2]]],
    rh_recode_malaria(vars = vars[3:4], .data = rh_df),
    folate = rh_df[[vars[5]]],
    rh_recode_tetanus(vars = vars[6:7], .data = rh_df)
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions recode the other reproductive health indicator questions. The third function recodes malaria during pregnancy indicators. The fourth function recodes tetanus toxoid immunisation during pregnancy coverage indicators. The final function provides overall recoding and concatenates the various other reproductive health indicators with the core variables.

To get the final recoded other reproductive health dataset, the following call is performed:

```{r rh_function, echo = TRUE, eval = FALSE}
## Other RH
rh_recoded_data <- rh_recode(
  vars = c(paste0("chm", 1:2), 
           paste0("fansidar", 1:2), "fol1", 
           paste0("tt", 1:2)),
  .data = raw_data_clean
)
```

which produces a data.frame with the core variables and the following recoded other reproductive health indicator values:

```{r rh_indicators}
indicators <- c(
  "mort1", "mort2",
  "mal_prevalence", "mal_no_treatment", "mal_appropriate_treatment",
  "folate", "tt_any", "tt_two_more"
)

desc <- c(
  "Still birth",
  "Under 5 mortality",
  "Malaria prevalence",
  "Malaria - no treatment",
  "Malaria - appropriate treatment",
  "Folic acid supplementation coverage",
  "Any dose of tetanus toxoid",
  "At least two doses of tetanus toxoid"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```



[^1]: R Core Team (2022). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

[^2]: https://www.fao.org/3/i1983e/i1983e.pdf

[^3]: https://documents.wfp.org/stellent/groups/public/documents/manual_guide_proced/wfp197216.pdf

[^4]: https://documents.wfp.org/stellent/groups/public/documents/manual_guide_proced/wfp211058.pdf

[^5]: https://www.fao.org/3/i5486e/i5486e.pdf

[^6]: Kroenke K, Spitzer RL, Williams JB. The PHQ-9: validity of a brief depression severity measure. J Gen Intern Med. 2001 Sep;16(9):606-13. doi: 10.1046/j.1525-1497.2001.016009606.x. PMID: 11556941; PMCID: PMC1495268.

[^7]: https://washdata.org/monitoring/drinking-water

[^8]: https://www.who.int/data/gho/indicator-metadata-registry/imr-details/80

<br/>
<br/>



