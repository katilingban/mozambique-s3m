---
title: "Sofala Simple Spatial Survey Method (S3M)"
subtitle: "Survey Data Cleaning and Processing Report"
author: 
    - name: Mark Myatt
    - name: Ernest Guevarra
date: '`r Sys.Date()`'
output: 
  html_document:
    toc: true
    toc_depth: 3
    self_contained: true
    code_download: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  echo = FALSE
)

suppressPackageStartupMessages(source("packages.R"))
for (f in list.files(here::here("R"), full.names = TRUE)) source (f)

targets::tar_load(
  c()
)
```

<style type="text/css">
  body{
  font-size: 12pt;
}
</style>

<br/>

## Overview of data cleaning and processing procedures implemented

This document provides information on the data cleaning and processing procedures applied to the dataset from the Sofala Simple Spatial Survey Method (S3M) survey. These procedures were implemented on the dataset using the [R language for statistical computing](https://www.r-project.org/)[^1]. These data cleaning and processing procedures were conceived and designed in such a way that they can be used for the data cleaning and processing of the Nampula and Zambezia endline survey dataset as well, given its similar data structure and indicator sets with only minor differences in variable naming and with some variables for infant and young child feeding. As such, attention and effort were put into designing generalisable R functions that can be used across the datasets and for each of the specific indicator sets common to both surveys.

These general and indicator set-specific functions for data cleaning and processing are mainly functions that perform the following procedures:

* Recoding of the responses to appropriate values that will allow for further recoding of responses into appropriate indicator definitions (see next point) and/or allow for subsequent analysis;

* Recoding of the responses into appropriate indicator definitions (specifically for indiators that require responses from multiple questions/variables such as IYCF, WASH, and the like); and,

* Restructuring of the recoded dataset/s to allow for subseqent analysis.

In this document, we describe these general functions used to process the data across all indicators sets, and we describe the the indicator set-specific functions used to process each indiator set.

<br/>

## General functions used across most indicator sets

Following are the general functions used across majority of the indicator sets.

### Get core variables required for analysis

```r
################################################################################
#
#'
#' Get core variables required for analysis
#'
#' @param raw_data_clean A roughly cleaned/processed raw dataset 
#'
#
################################################################################

get_core_variables <- function(raw_data_clean) {
  raw_data_clean |>
    subset(
      select = c(
        id, spid, district, ea_code, geolocation
      )
    )
}
```

This is a convenience function to retrieve identifier variables required for analysis. These variables are:

```{r survey_vars}
vars <- c("id", "spid", "district", "ea_code", "geolocation")
desc <- c("Unique identifier", "Sampling point identifier", "District name", "Enumeration area code", "Geolocation")

data.frame(vars, desc) |>
  knitr::kable(
    col.names = c("Variables", "Description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

This allows for structuring of processed data to be ready for indicator estimation and indicator mapping (for S3M).

### Spread a vector of categorial values into columns of unique variables

```r
################################################################################
#
#'
#' Convert character vector of categorical responses into unique variables
#' 
#' Function transforms a vector of categorical responses into `n` number of
#' new columns/variables equal to the number of unique categorical values.
#' 
#' @param x Vector of categorical values 
#' @param prefix A character string to prepend to the names of the new columns
#'   to be created
#' 
#'  
#'
#
################################################################################

spread_vector_to_columns <- function(x, fill = NULL, na_rm = FALSE, prefix) {
  values <- sort(unique(x), na.last = NA)
  
  if (!is.null(fill)) {
    values <- c(values, fill[!fill %in% values]) |>
      sort(na.last = NA)
  }
  
  if (na_rm) {
    values <- c(values, NA_integer_)
  }
  
  values <- values |>
    stringr::str_replace_all(
      pattern = " ", replacement = "_"
    )
  
  col_names <- paste(prefix, values, sep = "_")
  
  lapply(
    X = x,
    FUN = function(x, y) ifelse(x == y, 1, 0),
    y = values
  ) |>
    (\(x) do.call(rbind, x))() |>
    data.frame() |>
    (\(x) { names(x) <- col_names; x })()
}
```

This is a helper function to convert a vector of values into columns of new variables, each recoded into 1 or 0 based on interviewee response.

### Split a vector of select multiple values into columns of new variables

```r
################################################################################
#
#'
#' Split a vector of values from an ODK select multiple type of response
#'
#' This function operates on a single vector of select multiple type of
#' response. This is meant to be used within the `split_select_multiples()`
#' function below.
#'
#
################################################################################

split_select_multiple <- function(x, fill, na_rm = FALSE, prefix) {
  if (na_rm) {
    if (is.na(x)) {
      rep(NA_integer_, times = length(fill)) |>
        (\(x) { names(x) <- paste0(prefix, "_", fill); x })()
    } else {
      stringr::str_split(x, pattern = " ") |> 
        unlist() |> 
        as.integer() |> 
        spread_vector_to_columns(fill = fill, prefix = prefix) |>
        colSums(na.rm = TRUE)
    }
  } else {
    stringr::str_split(x, pattern = " ") |> 
      unlist() |> 
      as.integer() |> 
      spread_vector_to_columns(fill = fill, prefix = prefix) |>
      colSums(na.rm = TRUE)
  }
}
```

```r
################################################################################
#
#'
#' This function vectorises the `split_select_multiple()` across multiple
#' variables.
#'
#
################################################################################

split_select_multiples <- function(x, fill, na_rm = FALSE, prefix) {
  lapply(
    X = x,
    FUN = split_select_multiple,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  ) |>
    dplyr::bind_rows()
}
```

This is a set of helper functions for dealing with select multiple type of responses and the way ODK structures this type of data. The first function applies to a vector of select multiple responses while the second function vectorises this process across multiple vectors.

<br/>

## Indicator set-specific functions

The indicator set-specific functions generally include functions that perform the following sequence of processes:

1. Recode the responses to appropriate values:

    * for binary values of YES or NO; TRUE or FALSE, recode to 1 or 0 accordingly;
    * for categorial values, values are mapped to the values they represent and then spread and/or split into individual columns or variables; and,
    * for values representing NA values, convert to appropriate NA type (NA_integer_ or NA_character_).
    
2. Recode values to specific indicator set-specific definitions.

3. Combine all recode steps and processes within an overall function that recodes an indicator set-specific dataset appropriate for analysis.

Indicator set-specific data processing functions are named with a 2-5 letter code referencing the indicator set followed by the word `recode` and then followed by a descriptor of what type of recoding is being performed. Following are the 2-7 letter prefix for function names per indicator set:

```{r indicator_codes}
indicator_codes <- c(
  "carer", "ccare", "wem", "dev", "fcs", "fies", "fp", "imm", "hygiene", "stock", 
  "hdds", "work", "lcsi", "mddw", "phq", "nc", "net", "pica", "play", "pmtct", 
  "pnet", "preg", "rcsi", "rh", "san", "travel", "vita", "water", "wdds",
  "bf", "fg", "meals", "icfi", "fever", "dia", "rti"
)

indicator_desc <- c(
  "Mother/carer characteristics",
  "Childcare practices",
  "Women's empowerment/decision-making",
  "Child development",
  "Food consumption score",
  "Food insecurity experience scale",
  "Family planning",
  "Childhood immunisation",
  "Hygiene/handwashing",
  "Food stocks",
  "Household dietary diversity score",
  "Income and occupation",
  "Livelihoods coping strategy index",
  "Minimum dietary diversity - women",
  "Primary health questionnaire - 9",
  "Pre- and post-natal care",
  "Mosquito net availability",
  "Pica",
  "Child's play",
  "Prevention of mother-to-child transmission",
  "Mosquito net use during pregnancy",
  "Pregnancy",
  "Reduced coping strategies index",
  "Reproductive health - miscellaneous",
  "Sanitation",
  "Time-to-travel",
  "Vitamin A supplementation",
  "Water",
  "Women's dietary diversity score",
  "ICFI - Breastfeeding",
  "ICFI -  food groups and diet diversity",
  "ICFI - meal frequency",
  "ICFI score",
  "Childhood illnesses - fever",
  "Childhood illnesses - diarrhoea",
  "Childhood illnesses - respiratory tract infection"
)

data.frame(indicator_codes, indicator_desc) |>
  knitr::kable(
    col.names = c("Indicator Codes", "Indicator Description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    full_width = FALSE,
    position = "center",
    font_size = 16
  )
```


### Mother/carer characteristics

```r
################################################################################
#
#'
#' Recode mother characteristics indicators
#' 
#' mother_age	What is your age?
#' resp_marital_status	What is your marital status?
#' resp_edu	How many years of education have you completed?
#' q02	Does your husband/partner actually live in this household?
#' q02a	What is the age of your husband/partner?
#' q02b	What is the highest educational attainment of your husband/partner?
#' q03	For how many years has your family (household) lived in this place?
#'
#
################################################################################

## Recode mother/carer age -----------------------------------------------------

carer_recode_age <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}


## Recode mother/carer marital status ------------------------------------------

carer_recode_marital_status <- function(x, na_values,
                                        status = c("single", "married", 
                                                   "civil_union", 
                                                   "divorced_separated",
                                                   "widowed"),
                                        prefix) {
  x <- ifelse(x %in% na_values, NA, x)
  
  marital_status <- data.frame(
    marital_status = x, 
    spread_vector_to_columns(
      x = x,
      fill = 1:5,
      na_rm = FALSE,
      prefix = prefix
    ) |>
      (\(x) { names(x) <- paste0(prefix, "_", status); x })()
  )
  
  marital_status
}


## Recode mother/carer education achieved --------------------------------------

carer_recode_education <- function(x, na_values,
                                   edu_level = c(paste0("grade", 1:12),
                                                 "professional", "non_college",
                                                 "college", "literacy"),
                                   prefix) {
  x <- ifelse(x %in% na_values, NA, x)
  
  carer_education <- data.frame(
    x, 
    spread_vector_to_columns(
      x = x,
      fill = 1:16,
      na_rm = FALSE,
      prefix = prefix
    ) |>
      (\(x) { names(x) <- paste0(prefix, "_", edu_level); x })()
  )
  
  names(carer_education)[1] <- paste0(prefix, "_education")
  
  carer_education
}


## Overall recode function -----------------------------------------------------

carer_recode <- function(.data, 
                         age_na_values, marital_na_values,
                         education_na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  carer_age <- carer_recode_age(
    x = .data[["mother_age"]], na_values = age_na_values
  )
  
  carer_marital_status <- carer_recode_marital_status(
    x = .data[["resp_marital_status"]], 
    na_values = marital_na_values,
    prefix = "carer"
  )
  
  carer_education <- carer_recode_education(
    x = .data[["resp_edu"]], 
    na_values = education_na_values,
    prefix = "carer"
  )
  
  carer_with_partner <- ifelse(
    .data[["q02"]] %in% c(8, 9), NA,
    ifelse(
      .data[["q02"]] == 2, 0, 1
    )
  )
  
  partner_age <- carer_recode_age(
    x = .data[["q02a"]], na_values = age_na_values
  )
  
  partner_education <- carer_recode_education(
    x = .data[["q02b"]], 
    na_values = education_na_values,
    prefix = "partner"
  )
  
  data.frame(
    core_vars, carer_age, carer_marital_status, carer_education,
    carer_with_partner, partner_age, partner_education
  )
}
```

Complete recoding of the mother/carer characteristics can be performed through a call to the `carer_recode()` function as follows:

```{r carer_function, eval = FALSE, echo = TRUE}
carer_recoded_data = carer_recode(
  .data = raw_data_clean, 
  age_na_values = c(1:14, 88, 99, 100:1000), 
  marital_na_values = c(88, 99),
  education_na_values = c(88, 99)
)
```

which produces a data.frame with the core variables and the following recoded indicator values:

```{r mother_characteristics}
indicators <- c("carer_age", "carer_marital_status", "carer_education", "carer_with_partner", "partner_age", "partner_education")
desc <- c("Age of carer in years", "Marital status of carer", "Highest educational level achieved by carer", "Whether carer lives with spouse/partner", "Age of spouse/partner in years", "Highest educational level achieved by spouse/partner")

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Household dietary diversity score

```r
################################################################################
#
#' 
#' Process and recode household dietary diversity score data/indicators
#' 
#' Relevant variables:
#' 
#'  hdds0 Did the members of your household fast yesterday? 1=Yes; 2=No
#'  
#'  hdds1	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains corn/maize, rice, wheat, sorghum, millet or any 
#'    other grains during the day or night? 1=Yes; 2=No
#'    
#'  hdds2	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains white potatoes, white yam, white cassava, or any 
#'    other roots during the day or night? 1=Yes; 2=No
#'    
#'  hdds3	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains pumpkin, carrot, squash, or sweet potato that are 
#'    orange inside during the day or night?	1=Yes; 2=No
#'
#'  hdds4	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains dark green leafy vegetables, including wild forms 
#'    during the day or night? 1=Yes; 2=No
#'
#'  hdds5	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains other vegetables (e.g. tomato, onion, eggplant) 
#'    during the day or night?	1=Yes; 2=No
#'
#'  hdds6	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains ripe mango, cantaloupe, apricot (fresh or dried), 
#'    ripe papaya, dried peach, and 100% fruit juice made from these during the 
#'    day or night?	1=Yes; 2=No
#'
#'  hdds7	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains other fruits, including wild fruits and 100% fruit 
#'    juice made from these during the day or night? 1=Yes; 2=No
#'
#'  hdds8	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains liver, kidney, heart or other organ meats or 
#'    blood-based foods during the day or night?	1=Yes; 2=No
#'
#'  hdds9	Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains beef, pork, lamb, goat, rabbit, game, chicken, 
#'    duck, other birds, insects during the day or night? 1=Yes; 2=No
#'
#'  hdds10 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains eggs from chicken, duck, guinea fowl or any other 
#'    egg during the day or night? 1=Yes; 2=No
#'
#'  hdds11 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains fresh or dried fish or shellfish during the day or 
#'    night? 1=Yes; 2=No
#'
#'  hdds12 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains dried beans, dried peas, lentils, nuts, seeds or 
#'    foods made from these (eg. hummus, peanut butter) during the day or night?
#'    1=Yes; 2=No
#'
#'  hdds13 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains milk, cheese, yogurt or other milk products during 
#'    the day or night? 1=Yes; 2=No
#'
#'  hdds14 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains oil, fats or butter added to food or used for cooking 
#'    during the day or night? 1=Yes; 2=No
#'
#'  hdds15 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains sugar, honey, sweetened soda or sweetened juice 
#'    drinks, sugary foods such as chocolates, candies, cookies and cakes during 
#'    the day or night? 1=Yes; 2=No
#'
#'  hdds16 Yesterday, did you eat or drink foods as a meal or snack foods that 
#'    are made of or contains spices (black pepper, salt), condiments 
#'    (soy sauce, hot sauce), coffee, tea, alcoholic beverages during the day 
#'    or night? 1=Yes; 2=No
#'    
#' @param vars A vector of variables to use or a list of vectors of variables
#'   to use for HDDS
#' @param .data A data.frame from which variables should be taken
#' @param food_group A character value specifying food group to recode. Can be
#'   one of 12 food groups used in calculating the HDDS
#'    
#'    
#
################################################################################

## Recode a variable/set of variables for a specific food group ----------------

hdds_recode_group <- function(vars,
                              .data,
                              food_group = c("cereals", "tubers", "vegetables", 
                                             "fruits", "meat", "eggs", "fish",
                                             "legumes_seeds", "milk", "oils_fats",
                                             "sweets", "spices")) {
  food_group <- match.arg(food_group)
  
  if (length(vars) > 1) {
    if (!food_group %in% c("vegetables", "fruits", "meat")) {
      warning(
        paste0(
          "More than one food group variable specified. Please make sure that
          these variables are specific for the ", food_group, " food group."
        )
      )
    } 
    
    ## Get variables
    df <- .data[vars]
    
    ## Recode each variable to 1 and 0
    for (i in vars) {
      df[i] <- recode_yes_no(df[[i]], na_values = c("8", "9"))
    }
    
    ## Recode food group to 1 and 0
    fg <- recode_yes_no(x = rowSums(df, na.rm = TRUE), detect = "no")
  } else {
    if (food_group %in% c("vegetables", "fruits", "meat")) {
      warning(
        paste0(
          "Only one food group variable specified. Please make sure that
          there are no other variables that are specific for the ", food_group, 
          " food group."
        )
      )
    }    
    
    ## Calculate indicator
    fg <- recode_yes_no(.data[[vars]], na_values = c("8", "9"))
  }
  
  ## Return
  fg
}


## Recode multiple variables across multiple food groups -----------------------

hdds_recode_groups <- function(vars,
                               .data,
                               food_group = c("cereals", "tubers", "vegetables", 
                                              "fruits", "meat", "eggs", "fish",
                                              "legumes_seeds", "milk", "oils_fats",
                                              "sweets", "spices")) {
  .data_list <- rep(list(.data), 12)
  
  ## Check that length of vars is the same as length of food_group
  if (length(vars) != length(food_group)) {
    stop(
      "Number of variables/variable groups not the same as the number of
      specified food groups. Please verify specified variables."
    )
  }

  Map(
    f = hdds_recode_group, 
    vars = vars, 
    .data = .data_list, 
    food_group = food_group
  ) |>
    (\(x) { names(x) <- paste0("hdds_", food_group); x })() |>
    dplyr::bind_rows()
  
}


################################################################################
#
#'
#' Create named list of food group variables
#'
#
################################################################################

hdds_map_fg_vars <- function(cereals, tubers, vegetables, fruits, meat, 
                             eggs, fish, legumes_seeds, milk, oils_fats,
                             sweets, spices) {
  list(
    cereals = cereals,
    tubers = tubers,
    vegetables = vegetables,
    fruits = fruits,
    meat = meat,
    eggs = eggs,
    fish = fish,
    legumes_seeds = legumes_seeds,
    milk = milk,
    oils_fats = oils_fats,
    sweets = sweets,
    spices = spices
  )
} 


################################################################################
#
#'
#' Calculate HDDS
#'
#' @param fg_df A data.frame with 12 columns, one for each food group in HDDS
#' @param add Logical. Should the resulting score be added to fg_df? Default to
#'   TRUE
#' 
#'
#
################################################################################

hdds_calculate_score <- function(fg_df, add = TRUE) {
  ## Check that fg_df has 12 columns
  if (ncol(fg_df) != 12) {
    stop(
      "The food group data.frame needs to have 12 columns for each of the
      HDDS food groups. Please verify your dataset."
    )
  }
  
  hdds <- rowSums(fg_df, na.rm = TRUE)
  
  if (add) {
    data.frame(
      fg_df,
      hdds = hdds
    )
  } else {
    hdds
  }
}


hdds_recode <- function(vars,
                        .data,
                        food_group = c("cereals", "tubers", "vegetables", 
                                       "fruits", "meat", "eggs", "fish",
                                       "legumes_seeds", "milk", "oils_fats",
                                       "sweets", "spices")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- hdds_recode_groups(
    vars = vars, .data = .data, food_group = food_group
  ) |>
    hdds_calculate_score(add = TRUE)
  
  data.frame(core_vars, recoded_vars)
}
```

The first three functions above aid in recoding various household dietary diversity score food groups (12 in total) accordingly. The third function helps in mapping the food intake variables in the dataset to the specific food group that they belong to for use in the first 2 functions.

Once a food group data.frame has been created using the first 3 functions, the fourth function is used to calculate the HDDS based on the official FAO guidance[^2]. The final function performs the overall recode for HDDS and concatenates the food groups data.frame with the HDDS along with the core variables.

To get the final recoded HDDS dataset, the following call is performed:

```{r hdds_function, eval = FALSE, echo = TRUE}
## Household dietary diversity score variables
hdds_vars_map <- hdds_map_fg_vars(
  cereals = "hdds1", 
  tubers = "hdds2", 
  vegetables = c("hdds3", "hdds4", "hdds5"), 
  fruits = c("hdds6", "hdds7"), 
  meat = c("hdds8", "hdds9"), 
  eggs = "hdds10", fish = "hdds11", 
  legumes_seeds = "hdds12", 
  milk = "hdds13", 
  oils_fats = "hdds14", 
  sweets = "hdds15", 
  spices = "hdds16"
)

## Create the recoded HDDS dataset
hdds_recoded_data <- hdds_recode(vars = hdds_vars_map, .data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded HDDS indicator values:

```{r hdds_indicators}
indicators <- c(paste0("hdds_", c("cereals", "tubers", "vegetables", "fruits", "meat", "eggs", "fish", "legumes_seeds", "milk", "oils_fats", "sweets", "spices")), "hdds")
desc <- c(
  "HDDS cereals food group", "HDDS tubers food group", "HDDS vegetables food group", "HDDS fruits food group", "HDDS meat food group", "HDDS eggs food group", "HDDS fish food group", "HDDS legumes and seeds food group", "HDDS milk food group", "HDDS oils and fats food group", "HDDS sweets food group", "HDDS spices food group", "Household dietary diversity score" 
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Food consumption score

```r
################################################################################
#
#' 
#' Process and recode Food Consumption Score (FCS) data/indicators
#'
#' Relevant variables:
#'
#'   fcs0 - Did the members of your household fast in the last 7 days?
#'
#'     1=Yes; 2=No
#'
#'   fcs1	How many days in the past week/7 days has your household eaten 
#'     **maize** or any food made from or contains **maize**?
#'
#'   fcs2	How many days in the past week/7 days has your household eaten 
#'     **rice** or any food made from or contains **rice**?
#'
#'   fcs3	How many days in the past week/7 days has your household eaten 
#'     **bread** or any food made from or contains **wheat**?
#'
#'   fcs4	How many days in the past week/7 days has your household eaten 
#'     **tubers** or any food made from or contains **tubers**?
#'
#'   fcs5	How many days in the past week/7 days has your household eaten 
#'     **groundnuts and/or pulses** or any food made from or contains 
#'     **groundnuts and/or pulses**?
#'
#'   fcs6	How many days in the past week/7 days has your household eaten 
#'     **fish** or any food made from or contains **fish**?
#'
#'   fcs7	How many days in the past week/7 days has your household eaten 
#'     **fish powder or fish sauce used as flavouring** or any food made 
#'     from or contains **fish powder or fish sauce as flavouring**?	
#'
#'   fcs8	How many days in the past week/7 days has your household eaten 
#'     **red meat from sheep, goat, or beef** or any food made from or 
#'     contains **red meat from sheep, goat, or beef**?
#'
#'   fcs9	How many days in the past week/7 days has your household eaten 
#'     **white meat from poultry** or any food made from or contains 
#'     **white meat from poultry**?
#'
#'   fcs10	How many days in the past week/7 days has your household eaten 
#'     **vegetable oil and fats** or any food made from or contains 
#'     **vegetable oil and fats**?
#'
#'   fcs11	How many days in the past week/7 days has your household eaten 
#'     **eggs** or any food made from or contains **eggs**?
#'
#'   fcs12	How many days in the past week/7 days has your household eaten 
#'     **milk and dairy products** as a main food?
#'
#'   fcs13	How many days in the past week/7 days has your household taken 
#'     **milk in tea in small amounts**?
#'
#'   fcs14	How many days in the past week/7 days has your household eaten 
#'     **vegetables including leaves** or any food made from or contains 
#'     **vegetables including leaves**?
#'
#'   fcs15	How many days in the past week/7 days has your household eaten 
#'     **fruits** or any food made from or contains **fruits**?
#'
#'   fcs16	How many days in the past week/7days has your household eaten 
#'     **sweets and sugary foods** or any food made from or contains 
#'     **sugar**?
#'     
#' @param vars A vector of variables to use or a list of vectors of variables
#'   to use for FCS
#' @param .data A data.frame from which variables should be taken
#' @param food_group A character value specifying food group to recode. Can be
#'   one of 9 food groups used in calculating the HDDS
#'     
#
################################################################################

## Recode a variable or a set of variables for a specific FCS food group -------

fcs_recode_group <- function(vars, 
                             .data, 
                             food_group = c("staples", "pulses", "vegetables",
                                            "fruits", "meat_fish", "milk",
                                            "sugar", "oil", "condiments")) {
  food_group <- match.arg(food_group)
  
  if (length(vars) > 1) {
    if (!food_group %in% c("staples", "meat_fish", "condiments")) {
      warning(
        paste0(
          "More than one food group variable specified. Please make sure that
          these variables are specific for the ", food_group, " food group."
        )
      )
    } 
    
    ## Get variables
    df <- .data[vars]
    
    ## Recode each variable to 1 and 0
    for (i in vars) {
      df[i] <- ifelse(df[[i]] %in% c("88", "99"), NA, df[[i]])
    }
    
    ## Recode food group to 1 and 0
    fg <- rowSums(df, na.rm = TRUE) |>
      (\(x) ifelse(x > 7, 7, x))() |>
      as.integer()
  } else {
    if (food_group %in% c("staples", "meat_fish", "condiments")) {
      warning(
        paste0(
          "Only one food group variable specified. Please make sure that
          there are no other variables that are specific for the ", food_group, 
          " food group."
        )
      )
    }    
    
    ## Calculate indicator
    fg <- ifelse(.data[[vars]] %in% c("88", "99"), NA, .data[[vars]]) |>
      (\(x) ifelse(x > 7, 7, x))() |>
      as.integer()
  }
  
  ## Return
  fg
}

## Recode multiple sets of variables for multiple FCS food groups --------------

fcs_recode_groups <- function(vars,
                              .data,
                              food_group = c("staples", "pulses", "vegetables",
                                             "fruits", "meat_fish", "milk",
                                             "sugar", "oil", "condiments")) {
  .data_list <- rep(list(.data), 9)
  
  ## Check that length of vars is the same as length of food_group
  if (length(vars) != length(food_group)) {
    stop(
      "Number of variables/variable groups not the same as the number of
      specified food groups. Please verify specified variables."
    )
  }
  
  Map(
    f = fcs_recode_group, 
    vars = vars, 
    .data = .data_list, 
    food_group = food_group
  ) |>
    (\(x) { names(x) <- food_group; x })() |>
    dplyr::bind_rows()
  
}

## Map variables from dataset to each FCS food group

fcs_map_fg_vars <- function(staples, pulses, vegetables,
                            fruits, meat_fish, milk,
                            sugar, oil, condiments) {
  list(
    staples = staples,
    pulses = pulses,
    vegetables = vegetables,
    fruits = fruits,
    meat_fish = meat_fish,
    milk = milk,
    sugar = sugar,
    oil = oil,
    condiments = condiments
  )
}


################################################################################
#
#'
#' Calculate FCS
#'
#' @param fg_df A data.frame with 9 columns, one for each food group in FCS
#' @param add Logical. Should the resulting score be added to fg_df? Default to
#'   TRUE
#' 
#'
#
################################################################################

fcs_calculate_score <- function(fg_df, add = TRUE, 
                                weights = c(2, 3, 1, 1, 4, 4, 0.5, 0.5, 0)) {
  weights <- weights |>
    lapply(
      FUN = rep,
      times = nrow(fg_df)
    ) |>
    (\(x) { names(x) <- paste0("w", 1:length(weights)); x })() |>
    dplyr::bind_cols()
  
  fg_df_weighted <- fg_df * weights
  
  fcs <- rowSums(fg_df_weighted, na.rm = TRUE)
  
  if (add) {
    data.frame(
      fg_df,
      fcs = fcs
    )
  } else {
    fcs
  }
}


################################################################################
#
#'
#' Classify FCS
#' 
#' @param fcs A vector of food consumption scores
#' @param add Logical. Should classification be column binded to fcs? Default
#'   to FALSE.
#' @param spread Logical. Should classification be spread into columns?
#'   Default to FALSE.
#'
#
################################################################################

fcs_classify <- function(fcs, add = FALSE, spread = FALSE, cutoff = c(21, 35)) {
  fcs_class <- cut(
    x = fcs,
    breaks = c(0, cutoff[1], cutoff[2], Inf),
    labels = c("poor", "borderline", "acceptable"),
    include.lowest = FALSE, right = TRUE
  )
  
  if (spread) {
    fcs_class <- data.frame(
      fcs_class = fcs_class,
      spread_vector_to_columns(x = fcs_class, prefix = "fcs")
    )
  }
  
  if (add) {
    fcs_class <- data.frame(
      fcs, fcs_class
    )
  }
  
  fcs_class
}

## Overall FCS recode function -------------------------------------------------


fcs_recode <- function(vars,
                       .data,
                       food_group = c("staples", "pulses", "vegetables",
                                      "fruits", "meat_fish", "milk",
                                      "sugar", "oil", "condiments")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- fcs_recode_groups(
    vars = vars, .data = .data, food_group = food_group
  )
  
  recoded_vars |>
    fcs_calculate_score(add = FALSE) |>
    fcs_classify(add = TRUE, spread = TRUE) |>
    (\(x) data.frame(core_vars, recoded_vars, x))()
}
```

The first three functions above aid in recoding various food consumption score food groups (9 in total) accordingly. The third function helps in mapping the food intake variables in the dataset to the specific food group that they belong to for use in the first 2 functions.

Once a food group data.frame has been created using the first 3 functions, the fourth function is used to calculate the weighted FCS based on the official WFP guidance[^3]. The final function performs the overall recode for FCS and concatenates the food groups data.frame with the FCS and the FCS food insecurity classification along with the core variables.

To get the final recoded FCS dataset, the following call is performed:

```{r fcs_function, eval = FALSE, echo = TRUE}
## Food consumption score
fcs_vars_map <- fcs_map_fg_vars(
  staples = paste0("fcs", 1:4), 
  pulses = "fcs5", 
  vegetables = "fcs14", 
  fruits = "fcs15", 
  meat_fish = paste0("fcs", c(6, 8:9, 11)), 
  milk = "fcs12", 
  sugar = "fcs16", 
  oil = "fcs10", 
  condiments = paste0("fcs", c(7, 13))
)

fcs_recoded_data <- fcs_recode(vars = fcs_vars_map, .data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded FCS indicator values:

```{r fcs_indicators}
indicators <- c(paste0("fcs_", c("staples", "pulses", "vegetables", "fruits", "meat_fish", "milk", "sugar", "oil", "condiments")), "fcs", "fcs_class", "fcs_poor", "fcs_borderline", "fcs_acceptable")

desc <- c(
  "FCS staples food group", 
  "FCS pulses food group",
  "FCS vegetables food group",
  "FCS fruits food group",
  "FCS meat and fish food group",
  "FCS milk food group",
  "FCS sugary food group",
  "FCS oils food group",
  "FCS condiments food group",
  "Food consumption score",
  "Food consumption score food security classification",
  "Food consumption score - poor classification",
  "Food consupmtion score - borderline classification",
  "Food consumption score - acceptable classification"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Reduced coping strategies index

```r
################################################################################
#
#' 
#' Process and recode reduced coping strategy index (rCSI) data/indicators
#'
#' Relevant variables:
#'
#' How many times in the past week have you had to:
#'
#'   rcsi1	Rely on less preferred and less expensive foods? 
#'     88=Don't know; 99=No response
#'
#'   rcsi2	Borrow food, or rely on help from a friend or relative?
#'     88=Don't know; 99=No response
#'
#'   rcsi3 Limit portion size at mealtimes?
#'     88=Don't know; 99=No response
#'
#'   rcsi4	Restrict consumption by adults in order for small children to eat?
#'     88=Don't know; 99=No response
#'
#'   rcsi5	Reduce number of meals eaten in a day?
#'     88=Don't know; 99=No response
#'     
#
################################################################################

## Recode response to a specific coping strategy -------------------------------

rcsi_recode_strategy <- function(x, na_values = NA) {
  if (any(!is.na(na_values))) {
    ifelse(
      x %in% na_values, NA,
      ifelse(
        x > 7, 7, x
      )
    )
  } else {
    ifelse(x > 7, 7, x)
  }
}

## Recode responses to multiple coping strategies ------------------------------

rcsi_recode_strategies <- function(vars, .data, na_values = NA) {
  .data <- .data[vars]
  
  apply(
    X = .data,
    MARGIN = 2,
    FUN = rcsi_recode_strategy,
    na_values = na_values
  ) |>
    data.frame()
}


################################################################################
#
#'
#' Calculate rCSI
#'
#
################################################################################

rcsi_calculate_index <- function(rcsi_df, add = TRUE, 
                                 weights = c(1, 2, 1, 3, 1)) {
  weights <- weights |>
    lapply(
      FUN = rep,
      times = nrow(rcsi_df)
    ) |>
    (\(x) { names(x) <- paste0("w", 1:length(weights)); x })() |>
    dplyr::bind_cols()
  
  rcsi_df_weighted <- rcsi_df * weights
  
  rcsi <- rowSums(rcsi_df_weighted, na.rm = TRUE)
  
  if (add) {
    data.frame(
      rcsi_df,
      rcsi = rcsi
    )
  } else {
    rcsi
  }
}


################################################################################
#
#'
#' Classify rCSI into phases
#'
#
################################################################################

rcsi_classify <- function(rcsi, add = FALSE, spread = FALSE, 
                          phase = 3, cutoff = c(3, 18, 42)) {
  breaks <- c(0, cutoff[1:(phase - 1)], Inf)
  labels <- paste0("phase", 1:phase)
    
  rcsi_class <- cut(
    x = rcsi,
    breaks = breaks,
    labels = labels,
    include.lowest = TRUE, right = TRUE
  )
  
  if (spread) {
    rcsi_class <- data.frame(
      rcsi_class = rcsi_class,
      spread_vector_to_columns(x = rcsi_class, prefix = "rcsi")
    )
  }
  
  if (add) {
    rcsi_class <- data.frame(
      rcsi, rcsi_class
    )
  }
  
  rcsi_class
}


################################################################################
#
#'
#' Overall recode function
#'
#
################################################################################

rcsi_recode <- function(vars,
                       .data,
                       na_values = NA,
                       phase = 3,
                       cutoff = c(3, 18, 42)) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- rcsi_recode_strategies(
    vars = vars, .data = .data, na_values = na_values
  )
  
  recoded_vars |>
    rcsi_calculate_index(add = FALSE) |>
    rcsi_classify(add = TRUE, spread = TRUE, phase = phase, cutoff = cutoff) |>
    (\(x) data.frame(core_vars, recoded_vars, x))()
}

```

The first two functions recodes the different strategies based on reported frequencies with possible values of up to 7 per strategy. The third function then calculates the reduced coping strategies index using the specified weights and according to official WFP guidance[^4]. The fourth function classifies the weighted rCSI into corresponding food insecurity phases. The final function performs the overall recode for rCSI and concatenates the strategies data.frame with the rCSI and the rCSI classification along with the core variables.

To get the final recoded rCSI dataset, the following call is performed:

```{r, rcsi_function, eval = FALSE, echo = TRUE}
## Reduced coping strategies index (rCSI)
rcsi_recoded_data = rcsi_recode(
  vars = paste0("rcsi", 1:5),
  .data = raw_data_clean,
  na_values = c(88, 99)
)
```

which produces a data.frame with the core variables and the following recoded rCSI indicator values:

```{r rcsi_indicators}
indicators <- c(paste0("rcsi", 1:5), "rcsi", "rcsi_class", "rcsi_phase1", "rcsi_phase2", "rcsi_phase3")

desc <- c(
  "rCSI coping strategy 1", 
  "rCSI coping strategy 2",
  "rCSI coping strategy 3",
  "rCSI coping strategy 4",
  "rCSI coping strategy 5",
  "Reduced coping strategy index",
  "rCSI food insecurity phase classification",
  "rCSI phase 1 - minimal/none",
  "rCSI phase 2 - stressed",
  "rCSI phase 3 - crisis"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Women's dietary diversity score

```r
################################################################################
#
#'
#' Recode WDDS
#'
#
################################################################################

## Recode a variable or set of variables to a specific food group --------------

wdds_recode_group <- function(vars,
                              .data,
                              food_group = c("staples", "grean_leafy", 
                                             "other_vita", "fruits_vegetables", 
                                             "organ_meat", "meat_fish", "eggs", 
                                             "legumes", "milk")) {
  food_group <- match.arg(food_group)
  
  if (length(vars) > 1) {
    if (!food_group %in% c(
      "staples", "other_vita", "fruits_vegetables", "meat_fish", "legumes")
    ) {
      warning(
        paste0(
          "More than one food group variable specified. Please make sure that
          these variables are specific for the ", food_group, " food group."
        )
      )
    } 
    
    ## Get variables
    df <- .data[vars]
    
    ## Recode each variable to 1 and 0
    for (i in vars) {
      df[i] <- recode_yes_no(df[[i]], na_values = c("8", "9"))
    }
    
    ## Recode food group to 1 and 0
    fg <- recode_yes_no(x = rowSums(df, na.rm = TRUE), detect = "no") |>
      (\(x) { names(x) <- NULL; x })()
  } else {
    if (food_group %in% c(
      "staples", "other_vita", "fruits_vegetables", "meat_fish", "legumes")
    ) {
      warning(
        paste0(
          "Only one food group variable specified. Please make sure that
          there are no other variables that are specific for the ", food_group, 
          " food group."
        )
      )
    }    
    
    ## Calculate indicator
    fg <- recode_yes_no(.data[[vars]], na_values = c("8", "9"))
  }
  
  ## Return
  fg
}

## Recode variables for multiple foods groups ----------------------------------

wdds_recode_groups <- function(vars,
                               .data,
                               food_group = c("staples", "grean_leafy", 
                                              "other_vita", "fruits_vegetables", 
                                              "organ_meat", "meat_fish", "eggs", 
                                              "legumes", "milk")) {
  .data_list <- rep(list(.data), 9)
  
  ## Check that length of vars is the same as length of food_group
  if (length(vars) != length(food_group)) {
    stop(
      "Number of variables/variable groups not the same as the number of
      specified food groups. Please verify specified variables."
    )
  }
  
  Map(
    f = wdds_recode_group, 
    vars = vars, 
    .data = .data_list, 
    food_group = food_group
  ) |>
    (\(x) { names(x) <- paste0("wdds_", food_group); x })() |>
    dplyr::bind_rows()

}



################################################################################
#
#'
#' Create named list of food group variables
#'
#
################################################################################

wdds_map_fg_vars <- function(staples, grean_leafy, other_vita, 
                             fruits_vegetables, organ_meat, meat_fish, 
                             eggs, legumes, milk) {
  list(
    staples = staples, 
    grean_leafy = grean_leafy, 
    other_vita = other_vita, 
    fruits_vegetables = fruits_vegetables, 
    organ_meat = organ_meat, 
    meat_fish = meat_fish, 
    eggs = eggs, 
    legumes = legumes, 
    milk = milk
  )
} 



################################################################################
#
#'
#' Calculate WDDS
#'
#' @param fg_df A data.frame with 9 columns, one for each food group in WDDS
#' @param add Logical. Should the resulting score be added to fg_df? Default to
#'   TRUE
#' 
#'
#
################################################################################

wdds_calculate_score <- function(fg_df, add = TRUE) {
  ## Check that fg_df has 9 columns
  if (ncol(fg_df) != 9) {
    stop(
      "The food group data.frame needs to have 9 columns for each of the
      HDDS food groups. Please verify your dataset."
    )
  }
  
  wdds <- rowSums(fg_df, na.rm = TRUE)
  
  if (add) {
    data.frame(
      fg_df,
      wdds = wdds
    )
  } else {
    wdds
  }
}

## Overall WDDS recode function ------------------------------------------------

wdds_recode <- function(vars,
                        .data,
                        food_group = c("staples", "grean_leafy", 
                                       "other_vita", "fruits_vegetables", 
                                       "organ_meat", "meat_fish", "eggs", 
                                       "legumes", "milk")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- wdds_recode_groups(
    vars = vars, .data = .data, food_group = food_group
  ) |>
    wdds_calculate_score(add = TRUE)
  
  data.frame(core_vars, recoded_vars)
}

```

The first three functions above aid in recoding various women's dietary diversity score food groups (9 in total) accordingly. The third function helps in mapping the food intake variables in the dataset to the specific food group that they belong to for use in the first 2 functions.

Once a food group data.frame has been created using the first 3 functions, the fourth function is used to calculate the WDDS based on the official FAO guidance[^2]. The final function performs the overall recode for WDDS and concatenates the food groups data.frame with the WDDS along with the core variables.

To get the final recoded WDDS dataset, the following call is performed:

```{r wdds_function, eval = FALSE, echo = TRUE}
## Women's dietary diversity score (WDDS)
wdds_vars_map <- wdds_map_fg_vars(
  staples = c("nutmul1", "nutmul2"),
  grean_leafy = "nutmul10",
  other_vita = c("nutmul11", "nutmul12"),
  fruits_vegetables = c("nutmul13", "nutmul14"),
  organ_meat = "nutmul6",
  meat_fish = c("nutmul7", "nutmul8"),
  eggs = "nutmul9",
  legumes = c("nutmul3", "nutmul4"),
  milk = "nutmul5"
)

wdds_recoded_data <- wdds_recode(vars = wdds_vars_map, .data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded WDDS indicator values:

```{r wdds_indicators}
indicators <- c(paste0("wdds_", c("staples", "green_leafy", "other_vita", "fruits_vegetables", "organ_meat", "meat_fish", "eggs", "legumes", "milk")), "wdds")

desc <- c(
  "WDDS staples food group", "WDDS green and leafy vegetables food group", "WDDS other vitamin A-rich food group", "WDDS fruits and vegetables food group", "WDDS organ meat food group", "WDDS meat and fish food group", "WDDS eggs food group", "WDDS legumes and seeds food group", "WDDS milk food group", "Women's dietary diversity score" 
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Minimum dietary diversity - women

```r
################################################################################
#
#'
#' Recode MDD-W
#'
#
################################################################################

## Recode variable or set of variables for a specific food group ---------------

mddw_recode_group <- function(vars,
                              .data,
                              food_group = c("staples", "pulses", "nuts_seeds", 
                                             "milk", "meat_fish", "eggs",
                                             "green_leafy", "other_vita",
                                             "vegetables", "fruits")) {
  food_group <- match.arg(food_group)
  
  if (length(vars) > 1) {
    if (!food_group %in% c("staples", "other_vita", "meat_fish")) {
      warning(
        paste0(
          "More than one food group variable specified. Please make sure that
          these variables are specific for the ", food_group, " food group."
        )
      )
    } 
    
    ## Get variables
    df <- .data[vars]
    
    ## Recode each variable to 1 and 0
    for (i in vars) {
      df[i] <- recode_yes_no(df[[i]], na_values = c("8", "9"))
    }
    
    ## Recode food group to 1 and 0
    fg <- recode_yes_no(x = rowSums(df, na.rm = TRUE), detect = "no") |>
      (\(x) { names(x) <- NULL; x })()
  } else {
    if (food_group %in% c("staples", "other_vita", "meat_fish")) {
      warning(
        paste0(
          "Only one food group variable specified. Please make sure that
          there are no other variables that are specific for the ", food_group, 
          " food group."
        )
      )
    }    
    
    ## Calculate indicator
    fg <- recode_yes_no(.data[[vars]], na_values = c("8", "9"))
  }
  
  ## Return
  fg
}

## Recode variables for multiple food groups -----------------------------------

mddw_recode_groups <- function(vars,
                               .data,
                               food_group = c("staples", "pulses", "nuts_seeds", 
                                              "milk", "meat_fish", "eggs",
                                              "green_leafy", "other_vita",
                                              "vegetables", "fruits")) {
  .data_list <- rep(list(.data), 10)
  
  ## Check that length of vars is the same as length of food_group
  if (length(vars) != length(food_group)) {
    stop(
      "Number of variables/variable groups not the same as the number of
      specified food groups. Please verify specified variables."
    )
  }
  
  Map(
    f = mddw_recode_group, 
    vars = vars, 
    .data = .data_list, 
    food_group = food_group
  ) |>
    (\(x) { names(x) <- paste0("mddw_", food_group); x })() |>
    dplyr::bind_rows()

}


################################################################################
#
#'
#' Create named list of food group variables
#'
#
################################################################################

mddw_map_fg_vars <- function(staples, pulses, nuts_seeds, milk, meat_fish, 
                             eggs, green_leafy, other_vita, vegetables, 
                             fruits) {
  list(
    staples = staples,
    pulses = pulses,
    nuts_seeds = nuts_seeds,
    milk = milk,
    meat_fish = meat_fish, 
    eggs = eggs, 
    green_leafy = green_leafy,
    other_vita = other_vita,
    vegetables = vegetables,
    fruits = fruits
  )
} 



################################################################################
#
#'
#' Calculate MDDW
#'
#' @param fg_df A data.frame with 10 columns, one for each food group in WDDS
#' @param add Logical. Should the resulting score be added to fg_df? Default to
#'   TRUE
#' 
#'
#
################################################################################

mddw_calculate_score <- function(fg_df, add = TRUE) {
  ## Check that fg_df has 10 columns
  if (ncol(fg_df) != 10) {
    stop(
      "The food group data.frame needs to have 10 variables for each of the
      MDD-W food groups. Please verify your dataset."
    )
  }
  
  mddw <- rowSums(fg_df, na.rm = TRUE)
  
  if (add) {
    data.frame(
      fg_df,
      mddw_score = mddw,
      mddw = ifelse(mddw >= 5, 1, 0)
    )
  } else {
    data.frame(
      mddw_score = mddw,
      mddw = ifelse(mddw >= 5, 1, 0)
    )
  }
}

## Overall MDDW recode function ------------------------------------------------

mddw_recode <- function(vars,
                        .data,
                        food_group = c("staples", "pulses", "nuts_seeds", 
                                       "milk", "meat_fish", "eggs",
                                       "green_leafy", "other_vita",
                                       "vegetables", "fruits")) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- mddw_recode_groups(
    vars = vars, .data = .data, food_group = food_group
  ) |>
    mddw_calculate_score(add = TRUE)
  
  data.frame(core_vars, recoded_vars)
}
```

The first three functions above aid in recoding various minimum dietary diversity - women food groups (10 in total) accordingly. The third function helps in mapping the food intake variables in the dataset to the specific food group that they belong to for use in the first 2 functions.

Once a food group data.frame has been created using the first 3 functions, the fourth function is used to calculate the food group score and to recode those women who meet the minimum number of good groups to be classified as having a diverse diet (at least 5 food groups) based on the official FAO guidance[^5]. The final function performs the overall recode for MDD-W and concatenates the food groups data.frame with the MDD-W food groups score and the MDD-W classification along with the core variables.

To get the final recoded MDD-W dataset, the following call is performed:

```{r mddw_function, eval = FALSE, echo = TRUE}
## Minimum dietary diversity - women (MDD-W)
mddw_vars_map <- mddw_map_fg_vars(
  staples = c("nutmul1", "nutmul2"),
  pulses = "nutmul3",
  nuts_seeds = "nutmul4",
  milk = "nutmul5",
  meat_fish = c("nutmul6", "nutmul7", "nutmul8"), 
  eggs = "nutmul9", 
  green_leafy = "nutmul10",
  other_vita = c("nutmul11", "nutmul12"),
  vegetables = "nutmul13",
  fruits = "nutmul14"
)

mddw_recoded_data <- mddw_recode(vars = mddw_vars_map, .data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded MDD-W indicator values:

```{r mddw_indicators}
indicators <- c(paste0("mddw_", c("staples", "pulses", "nuts_seeds", "milk", "meat_fish", "eggs", "green_leafy", "other_vita", "vegetables", "fruits")), "mddw_score", "mddw")

desc <- c(
  "MDD-W staples food group", "MDD-W pulses food group", "MDD-W nuts and seeds food group", "MDD-W milk food group", "MDD-W meat and fish food group", "MDD-W eggs food group", "MDD-W green leafy vegetables food group", "MDD-W other vitamin A-rich food groups", "MDD-W vegetables food group", "MDD-W fruits food group", "MDD-W food groups score", "MDD-W" 
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Livelihoods coping strategy index

```r
################################################################################
#
#'
#' Recode LCSI indicators/data
#'
#
################################################################################

## Recode responses to specific coping strategy --------------------------------

lcsi_recode_strategy <- function(x, na_values) {
  if (any(!is.na(na_values))) {
    ifelse(
      x %in% na_values, NA,
      ifelse(
        x %in% c(1, 4), 1, 0
      )
    )
  } else {
    ifelse(x %in% c(1, 4), 1, 0)
  }
}

## Recode responses to multiple coping strategies ------------------------------

lcsi_recode_strategies <- function(vars, .data, na_values = NA) {
  .data <- .data[vars]
  
  apply(
    X = .data,
    MARGIN = 2,
    FUN = lcsi_recode_strategy,
    na_values = na_values
  ) |>
    data.frame()
}

## Classify a spoecific strategy into appropriate food insecurity phase --------

lcsi_classify_strategy <- function(lcsi, 
                                   phase = c(2, 3, 4, 2, 2, 3, 3, 4, 
                                              2, 4, 3, 2, 3, 3)) {
  if (length(lcsi) != length(phase)) {
    stop(
      "Set of livelihood coping strategies not the same length as the
      phase classifying values. Please check strategies set and/or
      phase classifying values."
    )
  }
  
  (lcsi * phase) |>
    (\(x) ifelse(x == 0, 1, x))() |>
    unlist()
}

################################################################################
#
#'
#' Calculate LCSI
#'
#
################################################################################

lcsi_calculate_index <- function(lcsi_df, add = TRUE,
                                 phase = c(2, 3, 4, 2, 2, 3, 3, 4, 
                                           2, 4, 3, 2, 3, 3)) {
  lcsi <- apply(
    X = lcsi_df,
    MARGIN = 1,
    FUN = lcsi_classify_strategy,
    phase = phase,
    simplify = FALSE
  ) |>
    dplyr::bind_rows()
  
  if (add) {
    data.frame(
      lcsi_df, 
      lcsi = lcsi)
  } else {
    lcsi
  }
}

## Classify based on worst coping strategy used --------------------------------

lcsi_classify <- function(lcsi, add = FALSE, spread = FALSE,
                          phase = c(2, 3, 4, 2, 2, 3, 3, 4, 
                                    2, 4, 3, 2, 3, 3)) {  
  lcsi <- apply(
    X = lcsi,
    MARGIN = 1,
    FUN = max,
    na.rm = TRUE,
    simplify = FALSE
  ) |>
    unlist() |>
    (\(x) ifelse(x == -Inf, NA, x))()
  
  lcsi_class <- lcsi |>
    (\(x) c("secure", "stress", "crisis", "emergency")[x])() |>
    (\(x) factor(x, levels = c("secure", "stress", "crisis", "emergency")))()
    
  if (spread) {
    lcsi_class <- spread_vector_to_columns(
      x = lcsi_class,
      prefix = "lcsi"
    )
  }
  
  if (add) {
    data.frame(lcsi, lcsi_class)
  } else {
    lcsi_class
  }
}


################################################################################
#
#'
#' Overall recode function
#'
#
################################################################################

lcsi_recode <- function(vars,
                        .data,
                        na_values = NA,
                        phase = c(2, 3, 4, 2, 2, 3, 3, 4, 
                                  2, 4, 3, 2, 3, 3)) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- lcsi_recode_strategies(
    vars = vars, .data = .data, na_values = na_values
  )
  
  recoded_vars |>
    lcsi_calculate_index(add = FALSE, phase = phase) |>
    lcsi_classify(add = TRUE, spread = TRUE, phase = phase) |>
    (\(x) data.frame(core_vars, recoded_vars, x))()
}

```

The first two functions above aid in recoding various livelihoods coping strategies employed. The next two functions then classifies each of the recoded responses to the strategies into the four food insecurity phases. The fifth function then takes all the classified strategies and determines the worst food insecurity phase strategy employed as the overall classification. These classifications are based on the official guidelines by WFP[^4]. The final function performs the overall recode for LCSI and concatenates the recoded strategies data.frame with the LCSI classification along with the core variables.

To get the final recoded LCSI dataset, the following call is performed:

```{r lcsi_function, echo = TRUE, eval = FALSE}
## Livelihoods coping strategy index (LCSI)
lcsi_recoded_data <- lcsi_recode(
  vars = c(
    "lcs01", "lcs02", "lcs03", "lcs04", "lcs05", "lcs06", "lcs07", 
    "lcs08", "lcs09", "lcs10", "lcs11", "lcs12", "lcs13", "lcs14"
  ),
  .data = raw_data_clean,
  na_values = c(5, 8, 9)
)
```

which produces a data.frame with the core variables and the following recoded LCSI indicator values:

```{r lcsi_indicators}
indicators <- c(paste0("lcsi", stringr::str_pad(1:14, width = 2, side = "left", pad = "0")), "lsci", "lsci_secure", "lcsi_stress", "lcsi_crisis", "lcsi_emergency")

desc <- c(
  "LCSI coping strategy 1",
  "LCSI coping strategy 2",
  "LCSI coping strategy 3",
  "LCSI coping strategy 4",
  "LCSI coping strategy 5",
  "LCSI coping strategy 6",
  "LCSI coping strategy 7",
  "LCSI coping strategy 8",
  "LCSI coping strategy 9",
  "LCSI coping strategy 10",
  "LCSI coping strategy 11",
  "LCSI coping strategy 12",
  "LCSI coping strategy 13",
  "LCSI coping strategy 14",
  "Livelihoods coping strategy index",
  "LCSI - secure phase",
  "LCSI - stress phase",
  "LCSI - crisis phase",
  "LCSI - emergency phase"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Primary health questionnaire

```r
################################################################################
#
#' 
#' Process and recode mental health data/indicators
#'
#' Relevant variables:
#'
#'   ment1 - In the last two weeks, how many days did you have little interest 
#'     or little happiness in doing things?
#'   
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment2 - In the last two weeks, how many days did you feel down, depresssed 
#'     or without motivation?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment3 - In the last two weeks, how many days did you have difficulty 
#'     sleeping, or staying asleep, or sleeping more than is customary?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment4 - In the last two weeks, how many days did you feel tired or with 
#'     little energy?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment5 - In the last two weeks, how many days did you have lack of appetite 
#'     or ate less?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment6 - In the last two weeks, how many days did you feel bad about 
#'     yourself or thought you were a failure or that you let down your family 
#'     or yourself?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   ment7 - In the last two weeks, how many days did you have difficulty 
#'     concentrating on things (such as reading a newspaper, watching 
#'     television, or listening to the radio?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   	ment8 - In the last two weeks, how many days did you feel slow in your 
#'      movements or in speaking; or the contrary, in which you felt agitated 
#'      and you stayed walking from one side to another, more than is customary?
#'
#'     1=No days; 2=Less than 1 week; 3=1 week or more; 4=Almost all days; 
#'     88=Don&apos;t know; 99=No response
#'
#'   	ment9 - With what frequency do you consume alcoholic beverages?
#'
#'      1=Never; 2=Monthly or less; 3=Between 2-4 times per month; 
#'      4=Between 2-3 times per week; 5=4 or more times per week; 
#'      88=Don&apos;t know; 99=No response
#'      
#
################################################################################

## Recode a specific PHQ symptom -----------------------------------------------

phq_recode_symptom <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x - 1)
}

## Recode multiple PHQ symptoms ------------------------------------------------

phq_recode_symptoms <- function(vars, .data, na_values) {
  .data <- .data[vars]
  
  apply(
    X = .data,
    MARGIN = 2,
    FUN = phq_recode_symptom,
    na_values = na_values
  ) |>
    data.frame()
}

## Calculate PHQ score ---------------------------------------------------------

phq_calculate_score <- function(phq_df, add = TRUE) {
  phq <- rowSums(phq_df, na.rm = TRUE)
  
  if (add) {
    data.frame(
      phq_df,
      phq = phq
    )
  } else {
    phq
  }
  
}

## Classify mental health status based on PHQ score ----------------------------

phq_classify <- function(phq, add = FALSE, spread = FALSE) {
  breaks <- c(1, 4, 9, 14, 19, 27)
  labels <- c("minimal", "mild", "moderate", "moderate severe", "severe")
  
  phq_class <- cut(
    x = phq,
    breaks = breaks,
    labels = labels,
    include.lowest = TRUE, right = TRUE
  ) |>
    as.character() |>
    (\(x) ifelse(is.na(x), "no depression", x))() |>
    factor(
      levels = c(
        "no depression", "minimal", "mild", 
        "moderate", "moderately severe", "severe"
      )
    )
  
  if (spread) {
    phq_class <- data.frame(
      phq_class = phq_class,
      spread_vector_to_columns(x = phq_class, prefix = "rcsi")
    )
  }
  
  if (add) {
    phq_class <- data.frame(
      phq, phq_class
    )
  }
  
  phq_class
}


################################################################################
#
#'
#' Overall recode function
#'
#
################################################################################

phq_recode <- function(vars,
                       .data,
                       na_values = NA) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- phq_recode_symptoms(
    vars = vars, .data = .data, na_values = na_values
  )
  
  recoded_vars |>
    phq_calculate_score(add = FALSE) |>
    phq_classify(add = TRUE, spread = TRUE) |>
    (\(x) data.frame(core_vars, recoded_vars, x))()
}
```

The first two functions facilitates the recoding of responses to each of the symptoms that are asked of the respondent as described by Kroenke et al (2001)[^6]. These recoded responses per symptom are then added to get an overall PHQ score (that can go up to 27) which is performed by the third function above. The fourth function then classifies each respondent's mental health status according to their PHQ score based on guidance described in Kroenke et al (2001)[^6]. The final function performs the overall recode for PHQ and concatenates the recoded symptoms data.frame with the PHQ score and PHQ classification along with the core variables.

To get the final recoded PHQ dataset, the following call is performed:

```{r phq_function, echo = TRUE, eval = FALSE}
## Primary health questionnaire - depression
phq_recoded_data = phq_recode(
  vars = paste0("ment", 1:9),
  .data = raw_data_clean,
  na_values = c(88, 99)
)
```

which produces a data.frame with the core variables and the following recoded PHQ indicator values:

```{r phq_indicators}
indicators <- c(paste0("ment", 1:9), "phq", "phq_class", "phq_no_depression", "phq_minimal", "phq_moderate", "phq_severe")

desc <- c(
  "PHQ symptom 1",
  "PHQ symptom 2",
  "PHQ symptom 3",
  "PHQ symptom 4",
  "PHQ symptom 5",
  "PHQ symptom 6",
  "PHQ symptom 7",
  "PHQ symptom 8",
  "PHQ symptom 9",
  "PHQ score",
  "PHQ classification",
  "PHQ - no depression",
  "PHQ - minimal depression",
  "PHQ - moderate depression",
  "PHQ - severe depression"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Childcare practices

```r
################################################################################
#
#' 
#' Process and recode childcare practices data/indicators
#'
#' Relevant variables:
#'
#'   ccare1 - Can you tell me what symptoms indicate that a child needs 
#'     immediate medical attention?  Please tell me all the symptoms that you 
#'     can. integer variables for the following categorical values:
#' 
#'     1=Fever; 
#'     2=Blood in stool; 
#'     3=Diarrhoea with dehydration (lack of tears/sunken eyes); 
#'     4=Cough, rapid respiration and/or difficulty breathing; 
#'     5=Unable to drink water, breastfeed, or eat; 
#'     6=Vomiting; 
#'     7=Convulsions; 
#'     8=Loss of consciousness; 
#'     9=Fatigue/no response/not wanting to play; 
#'     10=Neck rigidity; 
#'     88=Don't know; 
#'     99=No response
#'
#'   ccare2 - In relation to the child's health issues (e.g., vaccines, care, 
#'     etc.), do you have the support or involvement of the child's father?
#'     integer variables for the following categorical values:
#'     
#'     1=Yes; 
#'     2=No
#'
#'   ccare3 - In your opinion, what are the barriers or difficulties in taking 
#'     a child to receive health care treatment? integer variables for the
#'     following categorical values:
#'   
#'     1=Distance; 
#'     2=Transport; 
#'     3=Money; 
#'     4=Poor treatment at the health facility/hospital; 
#'     5=Other; 
#'     88=Don't know; 
#'     99=No response
#'     
#
################################################################################

## Recode responses to a specific childcare practices question -----------------

ccare_recode_responses <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}

## Recode responses to childcare practices questions on danger sign ------------

ccare_danger_recode <- function(vars, .data, 
                                na_values = c("88", "99"),
                                fill = 1:10, 
                                na_rm = TRUE, 
                                prefix = "ccare_danger",
                                threshold = 8) {
  x <- .data[[vars]]
  
  x <- ccare_recode_responses(x, na_values = na_values)
  
  danger_df <- split_select_multiples(
    x = x, fill = fill, na_rm = na_rm, prefix = prefix
  )
  
  ccare_danger_score <- rowSums(danger_df, na.rm = TRUE) |>
    (\(x) ifelse(x == 0, NA_integer_, x))()
  
  ccare_danger_prop <- ifelse(ccare_danger_score >= threshold, 1, 0)
  
  data.frame(
    danger_df, ccare_danger_score, ccare_danger_prop
  )
}

## Recode responses to childcare practices questions on participation  ---------

ccare_participation_recode <- function(x, na_values) {
  ifelse(
    x %in% na_values, NA,
    ifelse(
      x == 2, 0, 1
    )
  )
}

## Recode responses to childcare practices questions on barriers ---------------

ccare_barriers_recode <- function(vars, .data, 
                                  na_values = c("88", "99"),
                                  fill = 1:5, 
                                  na_rm = TRUE, 
                                  prefix = "ccare_barriers") {
  x <- .data[[vars]]
  
  x <- ccare_recode_responses(x, na_values = na_values)
  
  split_select_multiples(
    x = x, fill = fill, na_rm = na_rm, prefix = prefix
  )
}

## Overall childcare recode ----------------------------------------------------

ccare_recode <- function(.data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- data.frame(
    ccare_danger_recode(vars = "ccare1", .data = .data),
    ccare_participation = ccare_participation_recode(
      x = .data[["ccare2"]], na_values = c(8, 9)
    ),
    ccare_barriers_recode(vars = "ccare3", .data = .data)
  )
  
  data.frame(core_vars, recoded_vars)
}

```

The first function performs recoding of responses to a specific question in the child care practices indicator set. The second function uses the first function to recode responses from questions specific to danger signs to watch out for in children. The third function uses the first function to recode responses from questions specific to participation in child care. The fourth function uses the first function to recode responses from questions specific to barriers to child care. The final function performs the overall recode for child care practices and concatenates the various child care practices indicators with the core variables.

To get the final recoded child care dataset, the following call is performed:

```{r ccare_function, echo = TRUE, eval = FALSE}
## Childcare practices
ccare_recoded_data <- ccare_recode(.data = raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded child care practices indicator values:

```{r ccare_indicators}
indicators <- c(paste0("ccare_danger_", 1:10), "ccare_danger_score", "ccare_danger_prop", "ccare_participation", paste0("ccare_barriers", 1:5))

desc <- c(
  "Child care danger sign 1",
  "Child care danger sign 2",
  "Child care danger sign 3",
  "Child care danger sign 4",
  "Child care danger sign 5",
  "Child care danger sign 6",
  "Child care danger sign 7",
  "Child care danger sign 8",
  "Child care danger sign 9",
  "Child care danger sign 10",
  "Child care danger sign score",
  "Child care danger sign proportion with score of at least 8",
  "Child care involvement of father",
  "Child care barries 1",
  "Child care barries 2",
  "Child care barries 3",
  "Child care barries 4",
  "Child care barries 5"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Women's empowerment/decision-making

```r
################################################################################
#
# Process and recode decision making data/indicators
#
# Relevant variables:
#
#   ge1 - Appropriate age to marry? integer variables for the following
#     categorical values:
#     
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge2 - Use of condoms? integer variables for the following categorical
#     values:
# 
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge3 - Household responsibilities? integer variables for the following
#     categorical values:
#
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge4 - Family planning - number of childre to have? integer variables for
#     the following categorical values:
# 
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge5 - Family/land chores? integer variables for the following categorical
#     values:
#   
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge6 - Administration of finances (money) in the home? integer variables
#     for the following categorical values:
#
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge7 - How to raise children? integer variables for the following
#     categorical values:
#
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   ge8 - Hitting/spanking children? integer variables for the following
#     categorical values:
#     
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#   
#   ge9 - Seeking health care for pregnancy?	integer variables for the
#     following categorical values:
#   
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response 
#
#   ge10 - Seeking health care for a child? integer variables for the
#     following categorical values:
# 
#     1=The men; 
#     2=The women; 
#     3=Both men and women; 
#     88=Don't know; 
#     99=No response
#
#   von1 - Please, how much freedong of choice do you feel you have on what 
#     happens to your life? integer variables for the following categorical
#     values:
#
#     1=No choice; 
#     2=Little choice; 
#     3=Some choice; 
#     4=A lot of choice; 
#     88=Don't know; 
#     99=No response
#
#   von2 - Until what point do you feel you can decide your own destiny?
#     integer variables for the following categorical values:
# 
#     1=Not at all; 
#     2=A little; 
#     3=Enough; 
#     4=A lot; 
#     88=Don't know; 
#     99=No response
#
#   von3	In general, do you think you can make decisions by yourself, freely, 
#     without consulting your husband? Please, to what extent can you do this?
#     integer variables for the following categorical values:
#
#       1=Never; 
#       2=Sometimes; 
#       3=Almost always; 
#       4=Always; 
#       88=Don't know; 
#       99=No response
#
#   von4	Did you accept to participate in this survey of your own volition?
#     integer variables for the following categorical values:
#   
#     1=I accepted to participate voluntarily and freely; 
#     2=Yes, but I need the consent of the male head of household; 
#     3=No, I needed the consent of the male head of household; 
#     4=I need someone else's consent; 
#     88=Don't know; 
#     99=No response
#
################################################################################

## Recode responses to individual questions in indicator set -------------------

wem_recode_response <- function(x, na_values) {
  ifelse(x %in% na_values, NA_integer_, x)
}

## Recode responses to multiple questions in indicator set ---------------------

wem_recode_responses <- function(vars, .data, na_values) {
  vars <- .data[vars]
  
  apply(
    X = vars,
    MARGIN = 2,
    FUN = wem_recode_response,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame() |>
    (\(x) { names(x) <- names(vars); x } )()
}

## Recode responses to a specific decision topic -------------------------------

wem_recode_decision <- function(x, 
                                fill = NULL,
                                na_rm = FALSE,
                                prefix,
                                label = NULL) {
  wem_decision <- spread_vector_to_columns(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
  
  if (!is.null(label)) {
    names(wem_decision) <- paste0(prefix, "_", label)
    wem_decision
  }
  
  data.frame(x, wem_decision) |>
    (\(x) { names(x)[1] <- prefix; x } )()
}

## Recode responses to multiple decision topcis --------------------------------

wem_recode_decisions <- function(vars, .data, na_rm = FALSE, label = NULL) {
  x <- .data[vars]
  
  Map(
    f = wem_recode_decision,
    x = apply(X = x, MARGIN = 2, list) |>
      unlist(recursive = FALSE),
    prefix = vars,
    na_rm = na_rm,
    label = rep(list(label), length(vars))
  ) |>
    dplyr::bind_cols()
}

## Overall women's empowerment recode function

wem_recode <- function(.data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  wem_recoded_vars <- wem_recode_responses(
    vars = c(paste0("ge", 1:10), paste0("von", 1:4)) ,
    .data = .data,
    na_values = c(88, 99)
  ) 
  
  ge_recoded_vars <- wem_recode_decisions(
    vars = paste0("ge", 1:10),
    .data = wem_recoded_vars,
    na_rm = FALSE,
    label = c("men", "women", "both")
  )
  
  von_recoded_vars <- data.frame(
    wem_recode_decisions(
      vars = "von1",
      .data = wem_recoded_vars,
      na_rm = FALSE,
      label = c("no_choice", "little_choice", "some_choice", "lots_choices")
    ),
    von1_some_lots = ifelse(wem_recoded_vars[["von1"]] %in% 3:4, 1, 0),
    wem_recode_decisions(
      vars = "von2",
      .data = wem_recoded_vars,
      na_rm = FALSE,
      label = c("no", "little", "enough", "a_lot")
    ),
    von2_enough_lots = ifelse(wem_recoded_vars[["von2"]] %in% 3:4, 1, 0),
    wem_recode_decisions(
      vars = "von3",
      .data = wem_recoded_vars,
      na_rm = FALSE,
      label = c("never", "sometimes", "almost", "always")
    ),
    von3_almost_always = ifelse(wem_recoded_vars[["von3"]] %in% 3:4, 1, 0),
    wem_recode_decisions(
      vars = "von4",
      .data = wem_recoded_vars,
      na_rm = FALSE,
      label = c("freely", "freely_consent", "husband_consent", "someone_consent")
    ),
    von4_some_freely = ifelse(wem_recoded_vars[["von2"]] %in% 3:4, 0, 1)
  ) 
  
  data.frame(core_vars, ge_recoded_vars, von_recoded_vars)
}
```

The first two functions performs general recoding of the responses to the various questions in this indicator set. The next two functions performs specific recoding of responses to various decision topics. The final function provides overall recoding and concatenates the various women's empowerment indicators with the core variables.

To get the final recoded women's empowerment dataset, the following call is performed:

```{r wem_function, echo = TRUE, eval = FALSE}
## Women's empowerment and decision-makin
wem_recoded_data = wem_recode(raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded women's empowerment indicator values:

```{r wem_indicators}
indicators <- c(
  paste0("ge1", c("", "_men", "_women", "_both")),
  paste0("ge2", c("", "_men", "_women", "_both")),
  paste0("ge3", c("", "_men", "_women", "_both")),
  paste0("ge4", c("", "_men", "_women", "_both")),
  paste0("ge5", c("", "_men", "_women", "_both")),
  paste0("ge6", c("", "_men", "_women", "_both")),
  paste0("ge7", c("", "_men", "_women", "_both")),
  paste0("ge8", c("", "_men", "_women", "_both")),
  paste0("ge9", c("", "_men", "_women", "_both")),
  paste0("ge10", c("", "_men", "_women", "_both")),
  paste0("von1", c("", "_no_choice", "_little_choice", "_some_choice", "_lots_choices", "_some_lots")),
  paste0("von2", c("", "_no", "_little", "_enough", "_a_lot", "_enough_lots")),
  paste0("von3", c("", "_never", "_sometimes", "_almost", "_always", "_almost_always")),
  paste0("von4", c("", "_freely", "_freely_consent", "_husband_consent", "_someone_consent", "_some_freely"))
)

desc <- c(
  "Decision maker for topic 1",
  "Decision maker for topic 1 - men",
  "Decision maker for topic 1 - women",
  "Decision maker for topic 1 - both",
  "Decision maker for topic 2",
  "Decision maker for topic 2 - men",
  "Decision maker for topic 2 - women",
  "Decision maker for topic 2 - both",
  "Decision maker for topic 3",
  "Decision maker for topic 3 - men",
  "Decision maker for topic 3 - women",
  "Decision maker for topic 3 - both",
  "Decision maker for topic 4",
  "Decision maker for topic 4 - men",
  "Decision maker for topic 4 - women",
  "Decision maker for topic 4 - both",
  "Decision maker for topic 5",
  "Decision maker for topic 5 - men",
  "Decision maker for topic 5 - women",
  "Decision maker for topic 5 - both",
  "Decision maker for topic 6",
  "Decision maker for topic 6 - men",
  "Decision maker for topic 6 - women",
  "Decision maker for topic 6 - both",
  "Decision maker for topic 7",
  "Decision maker for topic 7 - men",
  "Decision maker for topic 7 - women",
  "Decision maker for topic 7 - both",
  "Decision maker for topic 8",
  "Decision maker for topic 8 - men",
  "Decision maker for topic 8 - women",
  "Decision maker for topic 8 - both",
  "Decision maker for topic 9",
  "Decision maker for topic 9 - men",
  "Decision maker for topic 9 - women",
  "Decision maker for topic 9 - both",
  "Decision maker for topic 10",
  "Decision maker for topic 10 - men",
  "Decision maker for topic 10- - women",
  "Decision maker for topic 10- both",
  "Amount of freedom of choice",
  "Amount of freedom of choice - none",
  "Amount of freedom of choice - little",
  "Amount of freedom of choice - some",
  "Amount of freedom of choice - lots",
  "Amount of freedom of choice - at least some",
  "Decide own destiny",
  "Decide own destiny - no",
  "Decide own destiny - little",
  "Decide own destiny - enough",
  "Decide own destiny - a lot",
  "Decide own destiny - at least enough",
  "Make decisions freely",
  "Make decisions freely - never",
  "Make decisions freely - sometimes",
  "Make decisions freely - almost always",
  "Make decisions freely - always",
  "Make decisions freely - at least almost always",
  "Decision to participate in survey",
  "Decision to participate in survey - freely",
  "Decision to participate in survey - freely with consent",
  "Decision to participate in survey - husband consent",
  "Decision to participate in survey - someone's consent",
  "Decision to participate in survey - at least freely with consent"
  )

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Child's play

```r
################################################################################
#
#'
#' Recode child play indicators
#'
#
################################################################################

## Recode responses to a question in the child play indicator set --------------

play_recode_response <- function(x, na_values) {
  ifelse(
    x %in% na_values, NA,
    ifelse(x == 2, 0, 1)
  )
}

## Recode responses to multiple questions in the child play indicator set ------

play_recode_responses <- function(vars, .data, na_values) {
  x <- .data[vars]
  
  apply(
    X = x,
    MARGIN = 2,
    FUN = play_recode_response,
    na_values = c(8, 9),
    simplify = TRUE
  ) |>
    data.frame() |>
    (\(x) { names(x) <- vars; x } )()
}

## Overall recode functions

play_recode <- function(vars, .data, na_values) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- play_recode_responses(
    vars = vars,
    .data = .data,
    na_values = na_values
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first two functions perform recoding of responses for each of the child play indicators. The final function provides overall recoding and concatenates the various child play indicators with the core variables.

To get the final recoded child's play dataset, the following call is performed:

```{r play_function, echo = TRUE, eval = FALSE}
## Play
play_recoded_data = play_recode(
  vars = paste0("play", c(paste0(1, letters[1:7]), 2, paste0(3, letters[1:6]))),
  .data = raw_data_clean,
  na_values = c(8, 9)
)
```

which produces a data.frame with the core variables and the following recoded child's play indicator values:

```{r play_indicators}
indicators <- c(
  paste0("play1", letters[1:7]), "play2", paste0("play3", letters[1:6])
)

desc <- c(
  "Play - sang songs",
  "Play - take a walk",
  "Play - play a game",
  "Play - read a book",
  "Play - told stories",
  "Play - name things",
  "Play - draw things",
  "Have a bag or box for child's things?",
  "Play - when giving a bath",
  "Play - when feeding",
  "Play - when changing clothes",
  "Play - while working at home",
  "Play - while working in the field",
  "Play - during free time"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
``` 

### Income and occupation

```r
################################################################################
#
#' 
#' Process and recode income and occupation data/indicators
#'
#' Relevant variables:
#'
#'   ig1 - What is the main source of income for the family in this household?
#'     integer variables for the following categorical values:
#'     
#'     1=Sale of agricultural products and/or animals; 
#'     2=Self-employed (commercial, service); 
#'     3=Assitência alimentar/ajuda/ganho ganho/biscate; 
#'     4=Fishing; 
#'     5=Salary, pension, remittance; 
#'     6=Other; 
#'     88=Don't know; 
#'     99=No response 
#'
#'  q08 - Adding the income of all the members of the household, including 
#'    remittances from people who are abroad, receipts, or salary of all adults 
#'    and children in the household who work, which of the following categories 
#'    is the closest to the monthly income of the family in this household?	
#'    integer variables for the following categorical values:
#'
#'    1=No income/or remittances not declared in money; 
#'    2=Less than 60-150 Mts per month; 
#'    3=From Mts 150.01 to Mts 500.00 per month; 
#'    4=From Mts 500.01 to Mts 1500.00 per month; 
#'    5=From Mts 1500.01 to Mts 3500.00 per month; 
#'    6=From Mts 3500.01 to Mts 5500.00 per month; 
#'    7=From Mts 5500.01 to Mts 7500.00 per month; 
#'    8=From Mts 7500.01 to Mts 9500.00 per month; 
#'    9=More than Mts 9500.00 per month; 
#'    88=Don't know; 
#'    99=No response
#'
#'  igs1 - What is your primary occupation? integer variables for the following
#'    categorical values:
#'
#'    1=Homemaker; 
#'    2=Your land; 
#'    3=Fishing; 
#'    4=Wage labor; 
#'    5=Business; 
#'    6=Other; 
#'    88=Don't know; 
#'    99=No response
#'
#'  igs2	What is the primary occupation of your husband/partner? integer
#'    variable for the following categorical values:
#'  
#'    1=None; 
#'    2=Your land; 
#'    3=Fishing; 
#'    4=Wage labor; 
#'    5=Business; 
#'    6=Other; 
#'    7=I do not have a partner/husband; 
#'    88=Don't know; 
#'    99=No response
#'    
#
################################################################################

## Recode responses to 

work_recode_response <- function(x, na_values, fill, na_rm = FALSE, 
                                 prefix, label = NULL) {
  x <- ifelse(x %in% na_values, NA, x)
  
  y <- spread_vector_to_columns(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
  
  if (!is.null(label)) {
    names(y) <- paste0(prefix, "_", label)
  }
  
  work_df <- data.frame(x, y) |>
    (\(x) { names(x)[1] <- prefix; x } )()
  
  work_df
}

work_recode_responses <- function(vars, .data, na_values, fill, na_rm = FALSE, 
                                  prefix, label = NULL) {
  x <- .data[vars]
  x <- apply(X = x, MARGIN = 2, list) |>
    unlist(recursive = FALSE)
  
  Map(
    f = work_recode_response,
    x = x,
    na_values = na_values,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix,
    label = label
  ) |>
    dplyr::bind_cols()
}


work_recode <- function(vars, .data, na_values, fill, na_rm = FALSE, 
                        prefix, label = NULL) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  recoded_vars <- work_recode_responses(
    vars = vars,
    .data = .data,
    na_values = na_values,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix,
    label = label
  )
  
  data.frame(core_vars, recoded_vars)
}
```

The first 2 functions recodes the variables on income source, income amount, occupation and partner's occupation into unique columns. The final function provides overall recoding and concatenates the various income and occupation indicators with the core variables.

To get the final recoded income and occupation dataset, the following call is performed:

```{r work_function, echo = TRUE, eval = FALSE}
## Income and occupation
work_recoded_data = work_recode(
  vars = c("ig1", "q08", "igs1", "igs2"),
  .data = raw_data_clean,
  na_values = list(
    c(88, 99), c(88, 99), 
    c(88, 99), c(7, 88, 99)
  ),
  fill = list(1:6, 1:9, 1:6, 1:6),
  na_rm = rep(list(FALSE), length(vars)),
  prefix = list(
    "income_source", "income_amount", 
    "occupation_carer", "occupation_partner"
  ),
  label = rep(list(NULL), length(vars))
)
```

which produces a data.frame with the core variables and the following recoded income and occupation indicator values:

```{r work_indicators}
indicators <- c(
  paste0("income_source", c("", paste0("_", 1:6))),
  paste0("income_amount", c("", paste0("_", 1:9))),
  paste0("occupation_carer", c("", paste0("_", 1:6))),
  paste0("occupation_partner", c("", paste0("_", 1:6)))
)

desc <- c(
  "Income source",
  "Income source - Sale of agricultural products and/or animals",
  "Income source - Self-employed (commercial, service)",
  "Income source - Assitência alimentar/ajuda/ganho ganho/biscate",
  "Income source - Fishing",
  "Income source - Salary, pension, remittance",
  "Income source - Other",
  "Income amount",
  "Income amount - No income/or remittances not declared in money",
  "Income amount - Less than 60-150 Mts per month",
  "Income amount - From Mts 150.01 to Mts 500.00 per month",
  "Income amount - From Mts 500.01 to Mts 1500.00 per month",
  "Income amount - From Mts 1500.01 to Mts 3500.00 per month",
  "Income amount - From Mts 3500.01 to Mts 5500.00 per month",
  "Income amount - From Mts 5500.01 to Mts 7500.00 per month",
  "Income amount - From Mts 7500.01 to Mts 9500.00 per month",
  "Income amount - More than Mts 9500.00 per month",
  "Occupation of carer",
  "Occupation of carer - Homemaker",
  "Occupation of carer - Your land",
  "Occupation of carer - Fishing",
  "Occupation of carer - Wage labor",
  "Occupation of carer - Business",
  "Occupation of carer - Other",
  "Occupation of partner",
  "Occupation of partner - None",
  "Occupation of partner - Your land",
  "Occupation of partner - Fishing",
  "Occupation of partner - Wage labor",
  "Occupation of partner - Business",
  "Occupation of partner - Other"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```

### Time-to-travel

```r
################################################################################
#
#'
#' Recode travel indicators/data
#'
#
################################################################################

## Recode others responses to mode of transportation ---------------------------

travel_recode_mode_other <- function(x, y) {
  ## Recode other modes of travel
  x[y %in% c("Barco", "Canoa")]                              <- 7
  x[y %in% c("Carro chapa")]                                 <- 8
  x[y %in% c("Chate")]                                       <- 9
  x[y %in% c("Comboio")]                                     <- 10
  x[stringr::str_detect(y, pattern = "Mota|Moto|mota|moto")] <- 11
  
  x
}

## Recode mode of transportation for specific travel purpose -------------------

travel_recode_mode <- function(x, na_values, fill, na_rm = FALSE, 
                               prefix, label = NULL) {
  x <- ifelse(x %in% na_values, NA, x)
  
  y <- spread_vector_to_columns(
    x = x,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix
  )
  
  if (!is.null(label)) {
    names(y) <- paste0(prefix, "_", label)
  }
  
  travel_df <- data.frame(x, y) |>
    (\(x) { names(x)[1] <- prefix; x } )()
  
  travel_df
}

## Recode mode of transportation for multiple travel purposes ------------------

travel_recode_modes <- function(vars, .data, na_values, fill, na_rm = FALSE, 
                                prefix, label = NULL) {
  x <- .data[vars]
  x <- apply(X = x, MARGIN = 2, list) |>
    unlist(recursive = FALSE)
  
  Map(
    f = travel_recode_mode,
    x = x,
    na_values = na_values,
    fill = fill,
    na_rm = na_rm,
    prefix = prefix,
    label = label
  ) |>
    dplyr::bind_cols()
}

## Recode time to travel for specific travel purpose ---------------------------

travel_recode_time <- function(x, na_values) {
  ifelse(x %in% na_values, NA, x)
}

## Recode time to travel for multiple travel purposes --------------------------

travel_recode_times <- function(vars, .data, na_values) {
  x <- .data[vars]
  
  apply(
    X = x,
    MARGIN = 2,
    FUN = travel_recode_time,
    na_values = na_values,
    simplify = TRUE
  ) |>
    data.frame() |>
    (\(x) 
      {
        names(x) <- paste0(
          "travel_times_", 
          c("health_facility", "local_markets", "water_sources")
        )
        x
      }
     )()
}

## Overall travel recode function ----------------------------------------------

travel_recode <- function(.data) {
  core_vars <- get_core_variables(raw_data_clean = .data)
  
  travel_modes <- travel_recode_modes(
    vars = c("gi1", "gi2m", "gi3m", "wt1m"),
    .data = .data,
    na_values = rep(list(c(88, 99)), length(vars)),
    fill = list(1:11, 1:5, 1:5, 1:5),
    na_rm = rep(list(FALSE), length(vars)),
    prefix = paste0(
      "travel_modes_", 
      c("town", "health_facility", "local_markets", "water_sources")
    ),
    label = rep(list(NULL), length(vars))
  )
  
  travel_times <- travel_recode_times(
    vars = c("gi2t", "gi3t", "wt1t"),
    .data = .data,
    na_values = c(88, 99, 888, 999)
  )
  
  data.frame(
    core_vars, travel_modes, travel_times
  )
}
```
The first 2 functions recodes the mode of transport used across the various travel purposes asked of respondent. The next 2 functions recode the time it takes to travel for the various travel purposes asked of respondent. The final function provides overall recoding and concatenates the various travel indicators with the core variables.

To get the final recoded travel dataset, the following call is performed:

```{r travel_function, echo = TRUE, eval = FALSE}
## Time-to-travel
travel_recode_data <- travel_recode(raw_data_clean)
```

which produces a data.frame with the core variables and the following recoded travel indicator values:

```{r travel_indicators}
indicators <- c(
  paste0("travel_modes_town", c("", paste0("_", 1:11))),
  paste0("travel_modes_health_facility", c("", paste0("_", 1:5))),
  paste0("travel_modes_local_markets", c("", paste0("_", 1:5))),
  paste0("travel_modes_water_sources", c("", paste0("_", 1:5))),
  paste0("travel_times_", c("health_facility", "local_markets", "water_sources"))
)

desc <- c(
  "Transport mode to nearest town",
  "Transport mode to nearest town - on foot",
  "Transport mode to nearest town - bicycle",
  "Transport mode to nearest town - bus",
  "Transport mode to nearest town - personal motorised vehicle",
  "Transport mode to nearest town - truck",
  "Transport mode to nearest town - don't travel",
  "Transport mode to nearest town - boat",
  "Transport mode to nearest town - rental car",
  "Transport mode to nearest town - chate",
  "Transport mode to nearest town - train",
  "Transport mode to nearest town - moto or mota hire",
  "Transport mode to health facility",
  "Transport mode to health facility - on foot",
  "Transport mode to health facility - bicycle",
  "Transport mode to health facility - motorcycle",
  "Transport mode to health facility - car",
  "Transport mode to health facility - other",
  "Transport mode to local markets",
  "Transport mode to local markets - on foot",
  "Transport mode to local markets - bicycle",
  "Transport mode to local markets - motorcycle",
  "Transport mode to local markets - car",
  "Transport mode to local markets - other",
  "Transport mode to water sources",
  "Transport mode to water sources - on foot",
  "Transport mode to water sources - bicycle",
  "Transport mode to water sources - motorcycle",
  "Transport mode to water sources - car",
  "Transport mode to water sources - other",
  "Travel time to health facility",
  "Travel time to local markets",
  "Travel time to water sources"
)

data.frame(indicators, desc) |>
  knitr::kable(
    col.names = c("Indicator variable", "Indicator description")
  ) |>
  kableExtra::kable_styling(
    bootstrap_options = c("striped", "bordered"),
    position = "center",
    full_width = FALSE,
    font_size = 16
  )
```


### Mosquito net

### Water, sanition and hygiene

### Child development

### Pica

### Childhood immunisation

### Vitamin A supplementation

### Childhood illnesses

### Infant and child feeding index

### Food insecurity experience scale

### Food stocks

### Pregnancy

### Pre- and post-natal care

### Prevention of mother-to-child transmission

### Mosquito net during pregnancy

### Family planning

### Other reproductive health indicators



[^1]: R Core Team (2022). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.

[^2]: https://www.fao.org/3/i1983e/i1983e.pdf

[^3]: https://documents.wfp.org/stellent/groups/public/documents/manual_guide_proced/wfp197216.pdf

[^4]: https://documents.wfp.org/stellent/groups/public/documents/manual_guide_proced/wfp211058.pdf

[^5]: https://www.fao.org/3/i5486e/i5486e.pdf

[^6]: Kroenke K, Spitzer RL, Williams JB. The PHQ-9: validity of a brief depression severity measure. J Gen Intern Med. 2001 Sep;16(9):606-13. doi: 10.1046/j.1525-1497.2001.016009606.x. PMID: 11556941; PMCID: PMC1495268.

<br/>
<br/>



